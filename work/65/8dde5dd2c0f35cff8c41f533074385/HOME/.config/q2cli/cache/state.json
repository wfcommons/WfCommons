{"plugins": {"vsearch": {"id": "vsearch", "name": "vsearch", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-vsearch", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This plugin wraps the vsearch application, and provides methods for clustering and dereplicating features and sequences.", "short_description": "Plugin for clustering and dereplicating with vsearch.", "actions": {"cluster_features_de_novo": {"id": "cluster_features_de_novo", "name": "De novo clustering of features.", "description": "Given a feature table and the associated feature sequences, cluster the features based on user-specified percent identity threshold of their sequences. This is not a general-purpose de novo clustering method, but rather is intended to be used for clustering the results of quality-filtering/dereplication methods, such as DADA2, or for re-clustering a FeatureTable at a lower percent identity than it was originally clustered at. When a group of features in the input table are clustered into a single feature, the frequency of that single feature in a given sample is the sum of the frequencies of the features that were clustered in that sample. Feature identifiers and sequences will be inherited from the centroid feature of each cluster. See the vsearch documentation for details on how sequence clustering is performed.", "signature": [{"name": "sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The sequences corresponding to the features in table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table to be clustered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "perc_identity", "repr": "Range(0, 1, inclusive_start=False, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [false, true]}, "fields": []}, "type": "parameter", "description": "The percent identity at which clustering should be performed. This parameter maps to vsearch's --id parameter.", "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "threads", "repr": "Range(0, 256, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, 256], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The number of threads to use for computation. Passing 0 will launch one thread per CPU core.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "clustered_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The table following clustering of features.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "clustered_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "Sequences representing clustered features.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "cluster_features_closed_reference": {"id": "cluster_features_closed_reference", "name": "Closed-reference clustering of features.", "description": "Given a feature table and the associated feature sequences, cluster the features against a reference database based on user-specified percent identity threshold of their sequences. This is not a general-purpose closed-reference clustering method, but rather is intended to be used for clustering the results of quality-filtering/dereplication methods, such as DADA2, or for re-clustering a FeatureTable at a lower percent identity than it was originally clustered at. When a group of features in the input table are clustered into a single feature, the frequency of that single feature in a given sample is the sum of the frequencies of the features that were clustered in that sample. Feature identifiers will be inherited from the centroid feature of each cluster. See the vsearch documentation for details on how sequence clustering is performed.", "signature": [{"name": "sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The sequences corresponding to the features in table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table to be clustered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The sequences to use as cluster centroids.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "perc_identity", "repr": "Range(0, 1, inclusive_start=False, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [false, true]}, "fields": []}, "type": "parameter", "description": "The percent identity at which clustering should be performed. This parameter maps to vsearch's --id parameter.", "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "strand", "repr": "Choices('plus', 'both')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["plus", "both"]}, "fields": []}, "type": "parameter", "description": "Search plus (i.e., forward) or both (i.e., forward and reverse complement) strands.", "default": "plus", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "threads", "repr": "Range(0, 256, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, 256], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The number of threads to use for computation. Passing 0 will launch one thread per CPU core.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "clustered_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The table following clustering of features.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "clustered_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The sequences representing clustered features, relabeled by the reference IDs.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "unmatched_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The sequences which failed to match any reference sequences. This output maps to vsearch's --notmatched parameter.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "dereplicate_sequences": {"id": "dereplicate_sequences", "name": "Dereplicate sequences.", "description": "Dereplicate sequence data and create a feature table and feature representative sequences. Feature identifiers in the resulting artifacts will be the sha1 hash of the sequence defining each feature. If clustering of features into OTUs is desired, the resulting artifacts can be passed to the cluster_features_* methods in this plugin.", "signature": [{"name": "sequences", "repr": "SampleData[Sequences] | SampleData[SequencesWithQuality] | SampleData[JoinedSequencesWithQuality]", "ast": {"type": "union", "members": [{"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequences", "predicate": null, "fields": []}]}, {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}]}, {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "JoinedSequencesWithQuality", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The sequences to be dereplicated.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "derep_prefix", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Merge sequences with identical prefixes. If a sequence is identical to the prefix of two or more longer sequences, it is clustered with the shortest of them. If they are equally long, it is clustered with the most abundant.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "dereplicated_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The table of dereplicated sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "dereplicated_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The dereplicated sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "join_pairs": {"id": "join_pairs", "name": "Join paired-end reads.", "description": "Join paired-end sequence reads using vsearch's merge_pairs function. The qmin, qminout, qmax, and qmaxout parameters should only need to be modified when working with older fastq sequence data. See the vsearch documentation for details on how paired-end joining is performed, and for more information on the parameters to this method.", "signature": [{"name": "demultiplexed_seqs", "repr": "SampleData[PairedEndSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}]}, "type": "input", "description": "The demultiplexed paired-end sequences to be joined.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "truncqual", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Truncate sequences at the first base with the specified quality score value or lower.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "minlen", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Sequences shorter than minlen after truncation are discarded.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "maxns", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Sequences with more than maxns N characters are discarded.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "allowmergestagger", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Allow joining of staggered read pairs.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "minovlen", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Minimum overlap length of forward and reverse reads for joining.", "default": 10, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "maxdiffs", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Maximum number of mismatches in the forward/reverse read overlap for joining.", "default": 10, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "minmergelen", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Minimum length of the joined read to be retained.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "maxmergelen", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Maximum length of the joined read to be retained.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "maxee", "repr": "Range(0.0, None)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Maximum number of expected errors in the joined read to be retained.", "default": null, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "qmin", "repr": "Range(-5, 2, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [-5, 2], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The minimum allowed quality score in the input.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "qminout", "repr": "Range(-5, 2, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [-5, 2], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The minimum allowed quality score to use in output.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "qmax", "repr": "Range(40, 41, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [40, 41], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The maximum allowed quality score in the input.", "default": 41, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "qmaxout", "repr": "Range(40, 41, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [40, 41], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The maximum allowed quality score to use in output.", "default": 41, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "threads", "repr": "Range(0, 8, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, 8], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The number of threads to use for computation. Does not scale much past 4 threads.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "joined_sequences", "repr": "SampleData[JoinedSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "JoinedSequencesWithQuality", "predicate": null, "fields": []}]}, "type": "output", "description": "The joined sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "uchime_ref": {"id": "uchime_ref", "name": "Reference-based chimera filtering with vsearch.", "description": "Apply the vsearch uchime_ref method to identify chimeric feature sequences. The results of this method can be used to filter chimeric features from the corresponding feature table. For additional details, please refer to the vsearch documentation.", "signature": [{"name": "sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature sequences to be chimera-checked.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table (used for computing total feature abundances).", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The non-chimeric reference sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "dn", "repr": "Range(0.0, None)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "No vote pseudo-count, corresponding to the parameter n in the chimera scoring function.", "default": 1.4, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "mindiffs", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Minimum number of differences per segment.", "default": 3, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "mindiv", "repr": "Range(0.0, None)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Minimum divergence from closest parent.", "default": 0.8, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "minh", "repr": "Range(0.0, 1.0, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "Minimum score (h). Increasing this value tends to reduce the number of false positives and to decrease sensitivity.", "default": 0.28, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "xn", "repr": "Range(1.0, None, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [1.0, null], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "No vote weight, corresponding to the parameter beta in the scoring function.", "default": 8.0, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "threads", "repr": "Range(0, 256, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, 256], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The number of threads to use for computation. Passing 0 will launch one thread per CPU core.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "chimeras", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The chimeric sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "nonchimeras", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The non-chimeric sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "stats", "repr": "UchimeStats", "ast": {"type": "expression", "builtin": false, "name": "UchimeStats", "predicate": null, "fields": []}, "type": "output", "description": "Summary statistics from chimera checking.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "uchime_denovo": {"id": "uchime_denovo", "name": "De novo chimera filtering with vsearch.", "description": "Apply the vsearch uchime_denovo method to identify chimeric feature sequences. The results of this method can be used to filter chimeric features from the corresponding feature table. For additional details, please refer to the vsearch documentation.", "signature": [{"name": "sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature sequences to be chimera-checked.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table (used for computing total feature abundances).", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "dn", "repr": "Range(0.0, None)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "No vote pseudo-count, corresponding to the parameter n in the chimera scoring function.", "default": 1.4, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "mindiffs", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Minimum number of differences per segment.", "default": 3, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "mindiv", "repr": "Range(0.0, None)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Minimum divergence from closest parent.", "default": 0.8, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "minh", "repr": "Range(0.0, 1.0, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "Minimum score (h). Increasing this value tends to reduce the number of false positives and to decrease sensitivity.", "default": 0.28, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "xn", "repr": "Range(1.0, None, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [1.0, null], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "No vote weight, corresponding to the parameter beta in the scoring function.", "default": 8.0, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "chimeras", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The chimeric sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "nonchimeras", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The non-chimeric sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "stats", "repr": "UchimeStats", "ast": {"type": "expression", "builtin": false, "name": "UchimeStats", "predicate": null, "fields": []}, "type": "output", "description": "Summary statistics from chimera checking.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "cluster_features_open_reference": {"id": "cluster_features_open_reference", "name": "Open-reference clustering of features.", "description": "Given a feature table and the associated feature sequences, cluster the features against a reference database based on user-specified percent identity threshold of their sequences. Any sequences that don't match are then clustered de novo. This is not a general-purpose clustering method, but rather is intended to be used for clustering the results of quality-filtering/dereplication methods, such as DADA2, or for re-clustering a FeatureTable at a lower percent identity than it was originally clustered at. When a group of features in the input table are clustered into a single feature, the frequency of that single feature in a given sample is the sum of the frequencies of the features that were clustered in that sample. Feature identifiers will be inherited from the centroid feature of each cluster. For features that match a reference sequence, the centroid feature is that reference sequence, so its identifier will become the feature identifier. The clustered_sequences result will contain feature representative sequences that are derived from the sequences input for all features in clustered_table. This will always be the most abundant sequence in the cluster. The new_reference_sequences result will contain the entire reference database, plus feature representative sequences for any de novo features. This is intended to be used as a reference database in subsequent iterations of cluster_features_open_reference, if applicable. See the vsearch documentation for details on how sequence clustering is performed.", "signature": [{"name": "sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The sequences corresponding to the features in table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table to be clustered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The sequences to use as cluster centroids.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "perc_identity", "repr": "Range(0, 1, inclusive_start=False, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [false, true]}, "fields": []}, "type": "parameter", "description": "The percent identity at which clustering should be performed. This parameter maps to vsearch's --id parameter.", "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "strand", "repr": "Choices('plus', 'both')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["plus", "both"]}, "fields": []}, "type": "parameter", "description": "Search plus (i.e., forward) or both (i.e., forward and reverse complement) strands.", "default": "plus", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "threads", "repr": "Range(0, 256, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, 256], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The number of threads to use for computation. Passing 0 will launch one thread per CPU core.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "clustered_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The table following clustering of features.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "clustered_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "Sequences representing clustered features.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "new_reference_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The new reference sequences. This can be used for subsequent runs of open-reference clustering for consistent definitions of features across open-reference feature tables.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "types": {"id": "types", "name": "types", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-types", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin defines semantic types and transformers supporting microbiome analysis.", "short_description": "Plugin defining types for microbiome analysis.", "actions": {}}, "taxa": {"id": "taxa", "name": "taxa", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-taxa", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin provides functionality for working with and visualizing taxonomic annotations of features.", "short_description": "Plugin for working with feature taxonomy annotations.", "actions": {"collapse": {"id": "collapse", "name": "Collapse features by their taxonomy at the specified level", "description": "Collapse groups of features that have the same taxonomic assignment through the specified level. The frequencies of all features will be summed when they are collapsed.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table to be collapsed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "taxonomy", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "description": "Taxonomic annotations for features in the provided feature table. All features in the feature table must have a corresponding taxonomic annotation. Taxonomic annotations that are not present in the feature table will be ignored.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "level", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The taxonomic level at which the features should be collapsed. All ouput features will have exactly this many levels of taxonomic annotation.", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "collapsed_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature table, where all features are now taxonomic annotations with the user-specified number of levels.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "filter_table": {"id": "filter_table", "name": "Taxonomy-based feature table filter.", "description": "This method filters features from a table based on their taxonomic annotations. Features can be retained in the resulting table by specifying one or more include search terms, and can be filtered out of the resulting table by specifying one or more exclude search terms. If both include and exclude are provided, the inclusion critera will be applied before the exclusion critera. Either include or exclude terms (or both) must be provided. Any samples that have a total frequency of zero after filtering will be removed from the resulting table.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table to be filtered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "taxonomy", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "description": "Taxonomic annotations for features in the provided feature table. All features in the feature table must have a corresponding taxonomic annotation. Taxonomic annotations for features that are not present in the feature table will be ignored.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "include", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "One or more search terms that indicate which taxa should be included in the resulting table. If providing more than one term, terms should be delimited by the query-delimiter character. By default, all taxa will be included.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "exclude", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "One or more search terms that indicate which taxa should be excluded from the resulting table. If providing more than one term, terms should be delimited by the query-delimiter character. By default, no taxa will be excluded.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "query_delimiter", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "The string used to delimit multiple search terms provided to include or exclude. This parameter should only need to be modified if the default delimiter (a comma) is used in the provided taxonomic annotations.", "default": ",", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "mode", "repr": "Choices('exact', 'contains')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["exact", "contains"]}, "fields": []}, "type": "parameter", "description": "Mode for determining if a search term matches a taxonomic annotation. \"contains\" requires that the annotation has the term as a substring; \"exact\" requires that the annotation is a perfect match to a search term.", "default": "contains", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "filtered_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The taxonomy-filtered feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "filter_seqs": {"id": "filter_seqs", "name": "Taxonomy-based feature sequence filter.", "description": "This method filters sequences based on their taxonomic annotations. Features can be retained in the result by specifying one or more include search terms, and can be filtered out of the result by specifying one or more exclude search terms. If both include and exclude are provided, the inclusion critera will be applied before the exclusion critera. Either include or exclude terms (or both) must be provided.", "signature": [{"name": "sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature sequences to be filtered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "taxonomy", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "description": "Taxonomic annotations for features in the provided feature sequences. All features in the feature sequences must have a corresponding taxonomic annotation. Taxonomic annotations for features that are not present in the feature sequences will be ignored.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "include", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "One or more search terms that indicate which taxa should be included in the resulting sequences. If providing more than one term, terms should be delimited by the query-delimiter character. By default, all taxa will be included.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "exclude", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "One or more search terms that indicate which taxa should be excluded from the resulting sequences. If providing more than one term, terms should be delimited by the query-delimiter character. By default, no taxa will be excluded.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "query_delimiter", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "The string used to delimit multiple search terms provided to include or exclude. This parameter should only need to be modified if the default delimiter (a comma) is used in the provided taxonomic annotations.", "default": ",", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "mode", "repr": "Choices('exact', 'contains')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["exact", "contains"]}, "fields": []}, "type": "parameter", "description": "Mode for determining if a search term matches a taxonomic annotation. \"contains\" requires that the annotation has the term as a substring; \"exact\" requires that the annotation is a perfect match to a search term.", "default": "contains", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "filtered_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The taxonomy-filtered feature sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "barplot": {"id": "barplot", "name": "Visualize taxonomy with an interactive bar plot", "description": "This visualizer produces an interactive barplot visualization of taxonomies. Interactive features include multi-level sorting, plot recoloring, sample relabeling, and SVG figure export.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table to visualize at various taxonomic levels.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "taxonomy", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "description": "Taxonomic annotations for features in the provided feature table. All features in the feature table must have a corresponding taxonomic annotation. Taxonomic annotations that are not present in the feature table will be ignored.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "sample-classifier": {"id": "sample_classifier", "name": "sample-classifier", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-sample-classifier", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin supports methods for supervised classification and regression of sample metadata, and other supervised machine learning methods.", "short_description": "Plugin for machine learning prediction of sample metadata.", "actions": {"regress_samples_ncv": {"id": "regress_samples_ncv", "name": "Nested cross-validated supervised learning regressor.", "description": "Predicts a continuous sample metadata column using a supervised learning regressor. Uses nested stratified k-fold cross validation for automated hyperparameter optimization and sample prediction. Outputs predicted values for each input sample, and relative importance of each feature for model accuracy.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Numeric]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Numeric", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Numeric metadata column to use as prediction target.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "cv", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of k-fold cross-validations to perform.", "default": 5, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "random_state", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Seed used by random number generator.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to run in parallel.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_estimators", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of trees to grow for estimation. More trees will improve predictive accuracy up to a threshold level, but will also increase time and memory requirements. This parameter only affects ensemble estimators, such as Random Forest, AdaBoost, ExtraTrees, and GradientBoosting.", "default": 100, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "estimator", "repr": "Choices('RandomForestRegressor', 'ExtraTreesRegressor', 'GradientBoostingRegressor', 'AdaBoostRegressor', 'ElasticNet', 'Ridge', 'Lasso', 'KNeighborsRegressor', 'LinearSVR', 'SVR')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["RandomForestRegressor", "ExtraTreesRegressor", "GradientBoostingRegressor", "AdaBoostRegressor", "ElasticNet", "Ridge", "Lasso", "KNeighborsRegressor", "LinearSVR", "SVR"]}, "fields": []}, "type": "parameter", "description": "Estimator method to use for sample prediction.", "default": "RandomForestRegressor", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "stratify", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Evenly stratify training and test data among metadata categories. If True, all values in column must match at least two samples.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "parameter_tuning", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically tune hyperparameters using random grid search.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "predictions", "repr": "SampleData[RegressorPredictions]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RegressorPredictions", "predicate": null, "fields": []}]}, "type": "output", "description": "Predicted target values for each input sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feature_importance", "repr": "FeatureData[Importance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Importance", "predicate": null, "fields": []}]}, "type": "output", "description": "Importance of each input feature to model accuracy.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "classify_samples_ncv": {"id": "classify_samples_ncv", "name": "Nested cross-validated supervised learning classifier.", "description": "Predicts a categorical sample metadata column using a supervised learning classifier. Uses nested stratified k-fold cross validation for automated hyperparameter optimization and sample prediction. Outputs predicted values for each input sample, and relative importance of each feature for model accuracy.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Categorical metadata column to use as prediction target.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "cv", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of k-fold cross-validations to perform.", "default": 5, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "random_state", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Seed used by random number generator.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to run in parallel.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_estimators", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of trees to grow for estimation. More trees will improve predictive accuracy up to a threshold level, but will also increase time and memory requirements. This parameter only affects ensemble estimators, such as Random Forest, AdaBoost, ExtraTrees, and GradientBoosting.", "default": 100, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "estimator", "repr": "Choices('RandomForestClassifier', 'ExtraTreesClassifier', 'GradientBoostingClassifier', 'AdaBoostClassifier', 'KNeighborsClassifier', 'LinearSVC', 'SVC')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["RandomForestClassifier", "ExtraTreesClassifier", "GradientBoostingClassifier", "AdaBoostClassifier", "KNeighborsClassifier", "LinearSVC", "SVC"]}, "fields": []}, "type": "parameter", "description": "Estimator method to use for sample prediction.", "default": "RandomForestClassifier", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "parameter_tuning", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically tune hyperparameters using random grid search.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "predictions", "repr": "SampleData[ClassifierPredictions]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "ClassifierPredictions", "predicate": null, "fields": []}]}, "type": "output", "description": "Predicted target values for each input sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feature_importance", "repr": "FeatureData[Importance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Importance", "predicate": null, "fields": []}]}, "type": "output", "description": "Importance of each input feature to model accuracy.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "probabilities", "repr": "SampleData[Probabilities]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Probabilities", "predicate": null, "fields": []}]}, "type": "output", "description": "Predicted class probabilities for each input sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "fit_classifier": {"id": "fit_classifier", "name": "Fit a supervised learning classifier.", "description": "Fit a supervised learning classifier. Outputs the fit estimator (for prediction of test samples and/or unknown samples) and the relative importance of each feature for model accuracy. Optionally use k-fold cross-validation for automatic recursive feature elimination and hyperparameter tuning.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Numeric metadata column to use as prediction target.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "step", "repr": "Range(0.0, 1.0, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "If optimize_feature_selection is True, step is the percentage of features to remove at each iteration.", "default": 0.05, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "cv", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of k-fold cross-validations to perform.", "default": 5, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "random_state", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Seed used by random number generator.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to run in parallel.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_estimators", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of trees to grow for estimation. More trees will improve predictive accuracy up to a threshold level, but will also increase time and memory requirements. This parameter only affects ensemble estimators, such as Random Forest, AdaBoost, ExtraTrees, and GradientBoosting.", "default": 100, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "estimator", "repr": "Choices('RandomForestClassifier', 'ExtraTreesClassifier', 'GradientBoostingClassifier', 'AdaBoostClassifier', 'KNeighborsClassifier', 'LinearSVC', 'SVC')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["RandomForestClassifier", "ExtraTreesClassifier", "GradientBoostingClassifier", "AdaBoostClassifier", "KNeighborsClassifier", "LinearSVC", "SVC"]}, "fields": []}, "type": "parameter", "description": "Estimator method to use for sample prediction.", "default": "RandomForestClassifier", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "optimize_feature_selection", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically optimize input feature selection using recursive feature elimination.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "parameter_tuning", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically tune hyperparameters using random grid search.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_estimator", "repr": "SampleEstimator[Classifier]", "ast": {"type": "expression", "builtin": false, "name": "SampleEstimator", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Classifier", "predicate": null, "fields": []}]}, "type": "output", "description": "Trained sample classifier.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feature_importance", "repr": "FeatureData[Importance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Importance", "predicate": null, "fields": []}]}, "type": "output", "description": "Importance of each input feature to model accuracy.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "fit_regressor": {"id": "fit_regressor", "name": "Fit a supervised learning regressor.", "description": "Fit a supervised learning regressor. Outputs the fit estimator (for prediction of test samples and/or unknown samples) and the relative importance of each feature for model accuracy. Optionally use k-fold cross-validation for automatic recursive feature elimination and hyperparameter tuning.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Numeric]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Numeric", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Numeric metadata column to use as prediction target.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "step", "repr": "Range(0.0, 1.0, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "If optimize_feature_selection is True, step is the percentage of features to remove at each iteration.", "default": 0.05, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "cv", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of k-fold cross-validations to perform.", "default": 5, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "random_state", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Seed used by random number generator.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to run in parallel.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_estimators", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of trees to grow for estimation. More trees will improve predictive accuracy up to a threshold level, but will also increase time and memory requirements. This parameter only affects ensemble estimators, such as Random Forest, AdaBoost, ExtraTrees, and GradientBoosting.", "default": 100, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "estimator", "repr": "Choices('RandomForestRegressor', 'ExtraTreesRegressor', 'GradientBoostingRegressor', 'AdaBoostRegressor', 'ElasticNet', 'Ridge', 'Lasso', 'KNeighborsRegressor', 'LinearSVR', 'SVR')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["RandomForestRegressor", "ExtraTreesRegressor", "GradientBoostingRegressor", "AdaBoostRegressor", "ElasticNet", "Ridge", "Lasso", "KNeighborsRegressor", "LinearSVR", "SVR"]}, "fields": []}, "type": "parameter", "description": "Estimator method to use for sample prediction.", "default": "RandomForestRegressor", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "optimize_feature_selection", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically optimize input feature selection using recursive feature elimination.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "parameter_tuning", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically tune hyperparameters using random grid search.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_estimator", "repr": "SampleEstimator[Regressor]", "ast": {"type": "expression", "builtin": false, "name": "SampleEstimator", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Regressor", "predicate": null, "fields": []}]}, "type": "output", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feature_importance", "repr": "FeatureData[Importance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Importance", "predicate": null, "fields": []}]}, "type": "output", "description": "Importance of each input feature to model accuracy.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "predict_classification": {"id": "predict_classification", "name": "Use trained classifier to predict target values for new samples.", "description": "Use trained estimator to predict target values for new samples. These will typically be unseen samples, e.g., test data (derived manually or from split_table) or samples with unknown values, but can theoretically be any samples present in a feature table that contain overlapping features with the feature table used to train the estimator.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_estimator", "repr": "SampleEstimator[Classifier]", "ast": {"type": "expression", "builtin": false, "name": "SampleEstimator", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Classifier", "predicate": null, "fields": []}]}, "type": "input", "description": "Sample classifier trained with fit_classifier.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to run in parallel.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "predictions", "repr": "SampleData[ClassifierPredictions]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "ClassifierPredictions", "predicate": null, "fields": []}]}, "type": "output", "description": "Predicted target values for each input sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "probabilities", "repr": "SampleData[Probabilities]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Probabilities", "predicate": null, "fields": []}]}, "type": "output", "description": "Predicted class probabilities for each input sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "predict_regression": {"id": "predict_regression", "name": "Use trained regressor to predict target values for new samples.", "description": "Use trained estimator to predict target values for new samples. These will typically be unseen samples, e.g., test data (derived manually or from split_table) or samples with unknown values, but can theoretically be any samples present in a feature table that contain overlapping features with the feature table used to train the estimator.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_estimator", "repr": "SampleEstimator[Regressor]", "ast": {"type": "expression", "builtin": false, "name": "SampleEstimator", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Regressor", "predicate": null, "fields": []}]}, "type": "input", "description": "Sample regressor trained with fit_regressor.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to run in parallel.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "predictions", "repr": "SampleData[RegressorPredictions]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RegressorPredictions", "predicate": null, "fields": []}]}, "type": "output", "description": "Predicted target values for each input sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "split_table": {"id": "split_table", "name": "Split a feature table into training and testing sets.", "description": "Split a feature table into training and testing sets. By default stratifies training and test sets on a metadata column, such that values in that column are evenly represented across training and test sets.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency\u00b9 | RelativeFrequency\u00b2 | PresenceAbsence\u00b3 | Balance\u2074 | PercentileNormalized\u2075]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "variable", "index": 1, "group": 140664538331568, "outputs": 1, "mapping": [[{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "Balance", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Balance", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "PercentileNormalized", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PercentileNormalized", "predicate": null, "fields": []}]]}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Numeric | Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Numeric", "predicate": null, "fields": []}, {"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}]}, "type": "parameter", "description": "Numeric metadata column to use as prediction target.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "test_size", "repr": "Range(0.0, 1.0, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "Fraction of input samples to exclude from training set and use for classifier testing.", "default": 0.2, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "random_state", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Seed used by random number generator.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "stratify", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Evenly stratify training and test data among metadata categories. If True, all values in column must match at least two samples.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "training_table", "repr": "FeatureTable[Frequency\u00b9 | RelativeFrequency\u00b2 | PresenceAbsence\u00b3 | Balance\u2074 | PercentileNormalized\u2075]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "variable", "index": 1, "group": 140664538331568, "outputs": 1, "mapping": [[{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "Balance", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Balance", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "PercentileNormalized", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PercentileNormalized", "predicate": null, "fields": []}]]}]}, "type": "output", "description": "Feature table containing training samples", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "test_table", "repr": "FeatureTable[Frequency\u00b9 | RelativeFrequency\u00b2 | PresenceAbsence\u00b3 | Balance\u2074 | PercentileNormalized\u2075]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "variable", "index": 1, "group": 140664538331568, "outputs": 1, "mapping": [[{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "Balance", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Balance", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "PercentileNormalized", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PercentileNormalized", "predicate": null, "fields": []}]]}]}, "type": "output", "description": "Feature table containing test samples", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "scatterplot": {"id": "scatterplot", "name": "Make 2D scatterplot and linear regression of regressor predictions.", "description": "Make a 2D scatterplot and linear regression of predicted vs. true values for a set of samples predicted using a sample regressor.", "signature": [{"name": "predictions", "repr": "SampleData[RegressorPredictions]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RegressorPredictions", "predicate": null, "fields": []}]}, "type": "input", "description": "Predicted values to plot on y axis. Must be predictions of numeric data produced by a sample regressor.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "truth", "repr": "MetadataColumn[Numeric]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Numeric", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Metadata column (true values) to plot on x axis.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "confusion_matrix": {"id": "confusion_matrix", "name": "Make a confusion matrix from sample classifier predictions.", "description": "Make a confusion matrix and calculate accuracy of predicted vs. true values for a set of samples classified using a sample classifier. If per-sample class probabilities are provided, will also generate Receiver Operating Characteristic curves and calculate area under the curve for each class.", "signature": [{"name": "predictions", "repr": "SampleData[ClassifierPredictions]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "ClassifierPredictions", "predicate": null, "fields": []}]}, "type": "input", "description": "Predicted values to plot on x axis. Should be predictions of categorical data produced by a sample classifier.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "truth", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Metadata column (true values) to plot on y axis.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "probabilities", "repr": "SampleData[Probabilities]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Probabilities", "predicate": null, "fields": []}]}, "type": "input", "description": "Predicted class probabilities for each input sample.", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "vmin", "repr": "Float | Str % Choices('auto')", "ast": {"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["auto"]}, "fields": []}]}, "type": "parameter", "description": "The minimum value to use for anchoring the colormap. If \"auto\", vmin is set to the minimum value in the data.", "default": "auto", "metavar": "VALUE", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "vmax", "repr": "Float | Str % Choices('auto')", "ast": {"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["auto"]}, "fields": []}]}, "type": "parameter", "description": "The maximum value to use for anchoring the colormap. If \"auto\", vmax is set to the maximum value in the data.", "default": "auto", "metavar": "VALUE", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "palette", "repr": "Choices('YellowOrangeBrown', 'YellowOrangeRed', 'OrangeRed', 'PurpleRed', 'RedPurple', 'BluePurple', 'GreenBlue', 'PurpleBlue', 'YellowGreen', 'summer', 'copper', 'viridis', 'cividis', 'plasma', 'inferno', 'magma', 'sirocco', 'drifting', 'melancholy', 'enigma', 'eros', 'spectre', 'ambition', 'mysteriousstains', 'daydream', 'solano', 'navarro', 'dandelions', 'deepblue', 'verve', 'greyscale')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["YellowOrangeBrown", "YellowOrangeRed", "OrangeRed", "PurpleRed", "RedPurple", "BluePurple", "GreenBlue", "PurpleBlue", "YellowGreen", "summer", "copper", "viridis", "cividis", "plasma", "inferno", "magma", "sirocco", "drifting", "melancholy", "enigma", "eros", "spectre", "ambition", "mysteriousstains", "daydream", "solano", "navarro", "dandelions", "deepblue", "verve", "greyscale"]}, "fields": []}, "type": "parameter", "description": "The color palette to use for plotting.", "default": "sirocco", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "summarize": {"id": "summarize", "name": "Summarize parameter and feature extraction information for a trained estimator.", "description": "Summarize parameter and feature extraction information for a trained estimator.", "signature": [{"name": "sample_estimator", "repr": "SampleEstimator[Classifier | Regressor]", "ast": {"type": "expression", "builtin": false, "name": "SampleEstimator", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "Classifier", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Regressor", "predicate": null, "fields": []}]}]}, "type": "input", "description": "Sample estimator trained with fit_classifier or fit_regressor.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "classify_samples": {"id": "classify_samples", "name": "Train and test a cross-validated supervised learning classifier.", "description": "Predicts a categorical sample metadata column using a supervised learning classifier. Splits input data into training and test sets. The training set is used to train and test the estimator using a stratified k-fold cross-validation scheme. This includes optional steps for automated feature extraction and hyperparameter optimization. The test set validates classification accuracy of the optimized estimator. Outputs classification results for test set. For more details on the learning algorithm, see http://scikit-learn.org/stable/supervised_learning.html", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Categorical metadata column to use as prediction target.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "test_size", "repr": "Range(0.0, 1.0, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "Fraction of input samples to exclude from training set and use for classifier testing.", "default": 0.2, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "step", "repr": "Range(0.0, 1.0, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "If optimize_feature_selection is True, step is the percentage of features to remove at each iteration.", "default": 0.05, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "cv", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of k-fold cross-validations to perform.", "default": 5, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "random_state", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Seed used by random number generator.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to run in parallel.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_estimators", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of trees to grow for estimation. More trees will improve predictive accuracy up to a threshold level, but will also increase time and memory requirements. This parameter only affects ensemble estimators, such as Random Forest, AdaBoost, ExtraTrees, and GradientBoosting.", "default": 100, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "estimator", "repr": "Choices('RandomForestClassifier', 'ExtraTreesClassifier', 'GradientBoostingClassifier', 'AdaBoostClassifier', 'KNeighborsClassifier', 'LinearSVC', 'SVC')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["RandomForestClassifier", "ExtraTreesClassifier", "GradientBoostingClassifier", "AdaBoostClassifier", "KNeighborsClassifier", "LinearSVC", "SVC"]}, "fields": []}, "type": "parameter", "description": "Estimator method to use for sample prediction.", "default": "RandomForestClassifier", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "optimize_feature_selection", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically optimize input feature selection using recursive feature elimination.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "parameter_tuning", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically tune hyperparameters using random grid search.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "palette", "repr": "Choices('YellowOrangeBrown', 'YellowOrangeRed', 'OrangeRed', 'PurpleRed', 'RedPurple', 'BluePurple', 'GreenBlue', 'PurpleBlue', 'YellowGreen', 'summer', 'copper', 'viridis', 'cividis', 'plasma', 'inferno', 'magma', 'sirocco', 'drifting', 'melancholy', 'enigma', 'eros', 'spectre', 'ambition', 'mysteriousstains', 'daydream', 'solano', 'navarro', 'dandelions', 'deepblue', 'verve', 'greyscale')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["YellowOrangeBrown", "YellowOrangeRed", "OrangeRed", "PurpleRed", "RedPurple", "BluePurple", "GreenBlue", "PurpleBlue", "YellowGreen", "summer", "copper", "viridis", "cividis", "plasma", "inferno", "magma", "sirocco", "drifting", "melancholy", "enigma", "eros", "spectre", "ambition", "mysteriousstains", "daydream", "solano", "navarro", "dandelions", "deepblue", "verve", "greyscale"]}, "fields": []}, "type": "parameter", "description": "The color palette to use for plotting.", "default": "sirocco", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_estimator", "repr": "SampleEstimator[Classifier]", "ast": {"type": "expression", "builtin": false, "name": "SampleEstimator", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Classifier", "predicate": null, "fields": []}]}, "type": "output", "description": "Trained sample estimator.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feature_importance", "repr": "FeatureData[Importance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Importance", "predicate": null, "fields": []}]}, "type": "output", "description": "Importance of each input feature to model accuracy.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "predictions", "repr": "SampleData[ClassifierPredictions]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "ClassifierPredictions", "predicate": null, "fields": []}]}, "type": "output", "description": "Predicted target values for each input sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "model_summary", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Summarized parameter and (if enabled) feature selection information for the trained estimator.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "accuracy_results", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Accuracy results visualization.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "probabilities", "repr": "SampleData[Probabilities]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Probabilities", "predicate": null, "fields": []}]}, "type": "output", "description": "Predicted class probabilities for each input sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "heatmap", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "A heatmap of the top 50 most important features from the table.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "classify_samples_from_dist": {"id": "classify_samples_from_dist", "name": "Run k-nearest-neighbors on a labeled distance matrix.", "description": "Run k-nearest-neighbors on a labeled distance matrix. Return cross-validated (leave one out) predictions and  accuracy. k = 1 by default", "signature": [{"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "input", "description": "a distance matrix", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Categorical metadata column to use as prediction target.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "k", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of nearest neighbors", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "palette", "repr": "Choices('YellowOrangeBrown', 'YellowOrangeRed', 'OrangeRed', 'PurpleRed', 'RedPurple', 'BluePurple', 'GreenBlue', 'PurpleBlue', 'YellowGreen', 'summer', 'copper', 'viridis', 'cividis', 'plasma', 'inferno', 'magma', 'sirocco', 'drifting', 'melancholy', 'enigma', 'eros', 'spectre', 'ambition', 'mysteriousstains', 'daydream', 'solano', 'navarro', 'dandelions', 'deepblue', 'verve', 'greyscale')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["YellowOrangeBrown", "YellowOrangeRed", "OrangeRed", "PurpleRed", "RedPurple", "BluePurple", "GreenBlue", "PurpleBlue", "YellowGreen", "summer", "copper", "viridis", "cividis", "plasma", "inferno", "magma", "sirocco", "drifting", "melancholy", "enigma", "eros", "spectre", "ambition", "mysteriousstains", "daydream", "solano", "navarro", "dandelions", "deepblue", "verve", "greyscale"]}, "fields": []}, "type": "parameter", "description": "The color palette to use for plotting.", "default": "sirocco", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "predictions", "repr": "SampleData[ClassifierPredictions]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "ClassifierPredictions", "predicate": null, "fields": []}]}, "type": "output", "description": "leave one out predictions for each sample", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "accuracy_results", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Accuracy results visualization.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "regress_samples": {"id": "regress_samples", "name": "Train and test a cross-validated supervised learning regressor.", "description": "Predicts a continuous sample metadata column using a supervised learning regressor. Splits input data into training and test sets. The training set is used to train and test the estimator using a stratified k-fold cross-validation scheme. This includes optional steps for automated feature extraction and hyperparameter optimization. The test set validates classification accuracy of the optimized estimator. Outputs classification results for test set. For more details on the learning algorithm, see http://scikit-learn.org/stable/supervised_learning.html", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Numeric]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Numeric", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Numeric metadata column to use as prediction target.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "test_size", "repr": "Range(0.0, 1.0, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "Fraction of input samples to exclude from training set and use for classifier testing.", "default": 0.2, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "step", "repr": "Range(0.0, 1.0, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "If optimize_feature_selection is True, step is the percentage of features to remove at each iteration.", "default": 0.05, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "cv", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of k-fold cross-validations to perform.", "default": 5, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "random_state", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Seed used by random number generator.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to run in parallel.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_estimators", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of trees to grow for estimation. More trees will improve predictive accuracy up to a threshold level, but will also increase time and memory requirements. This parameter only affects ensemble estimators, such as Random Forest, AdaBoost, ExtraTrees, and GradientBoosting.", "default": 100, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "estimator", "repr": "Choices('RandomForestRegressor', 'ExtraTreesRegressor', 'GradientBoostingRegressor', 'AdaBoostRegressor', 'ElasticNet', 'Ridge', 'Lasso', 'KNeighborsRegressor', 'LinearSVR', 'SVR')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["RandomForestRegressor", "ExtraTreesRegressor", "GradientBoostingRegressor", "AdaBoostRegressor", "ElasticNet", "Ridge", "Lasso", "KNeighborsRegressor", "LinearSVR", "SVR"]}, "fields": []}, "type": "parameter", "description": "Estimator method to use for sample prediction.", "default": "RandomForestRegressor", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "optimize_feature_selection", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically optimize input feature selection using recursive feature elimination.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "stratify", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Evenly stratify training and test data among metadata categories. If True, all values in column must match at least two samples.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "parameter_tuning", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically tune hyperparameters using random grid search.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_estimator", "repr": "SampleEstimator[Regressor]", "ast": {"type": "expression", "builtin": false, "name": "SampleEstimator", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Regressor", "predicate": null, "fields": []}]}, "type": "output", "description": "Trained sample estimator.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feature_importance", "repr": "FeatureData[Importance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Importance", "predicate": null, "fields": []}]}, "type": "output", "description": "Importance of each input feature to model accuracy.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "predictions", "repr": "SampleData[RegressorPredictions]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RegressorPredictions", "predicate": null, "fields": []}]}, "type": "output", "description": "Predicted target values for each input sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "model_summary", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Summarized parameter and (if enabled) feature selection information for the trained estimator.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "accuracy_results", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Accuracy results visualization.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "metatable": {"id": "metatable", "name": "Convert (and merge) positive numeric metadata (in)to feature table.", "description": "Convert numeric sample metadata from TSV file into a feature table. Optionally merge with an existing feature table. Only numeric metadata will be converted; categorical columns will be silently dropped. By default, if a table is used as input only samples found in both the table and metadata (intersection) are merged, and others are silently dropped. Set missing_samples=\"error\" to raise an error if samples found in the table are missing from the metadata file. The metadata file can always contain a superset of samples. Note that columns will be dropped if they are non-numeric, contain no unique values (zero variance), contain only empty cells, or contain negative values. This method currently only converts postive numeric metadata into feature data. Tip: convert categorical columns to dummy variables to include them in the output feature table.", "signature": [{"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata file to convert to feature table.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "ignore", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "missing_values", "repr": "Choices('drop_samples', 'drop_features', 'error', 'fill')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["drop_samples", "drop_features", "error", "fill"]}, "fields": []}, "type": "parameter", "description": "How to handle missing values (nans) in metadata. Either \"drop_samples\" with missing values, \"drop_features\" with missing values, \"fill\" missing values with zeros, or \"error\" if any missing values are found.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "drop_all_unique", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If True, columns that contain a unique value for every ID will be dropped.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "converted_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "Converted feature table", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "heatmap": {"id": "heatmap", "name": "Generate heatmap of important features.", "description": "Generate a heatmap of important features. Features are filtered based on importance scores; samples are optionally grouped by sample metadata; and a heatmap is generated that displays (normalized) feature abundances per sample.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "importance", "repr": "FeatureData[Importance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Importance", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature importances.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Sample metadata column to use for sample labeling or grouping.", "default": null, "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "feature_metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Feature metadata (e.g., taxonomy) to use for labeling features in the heatmap.", "default": null, "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "feature_count", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Filter feature table to include top N most important features. Set to zero to include all features.", "default": 50, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "importance_threshold", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Filter feature table to exclude any features with an importance score less than this threshold. Set to zero to include all features.", "default": 0, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "group_samples", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Group samples by sample metadata.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "normalize", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Normalize the feature table by adding a psuedocount of 1 and then taking the log10 of the table.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "ignore", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metric", "repr": "Choices('kulsinski', 'cosine', 'dice', 'cityblock', 'matching', 'sokalsneath', 'canberra', 'hamming', 'jaccard', 'mahalanobis', 'correlation', 'seuclidean', 'sokalmichener', 'chebyshev', 'sqeuclidean', 'rogerstanimoto', 'euclidean', 'minkowski', 'yule', 'russellrao', 'braycurtis')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["kulsinski", "cosine", "dice", "cityblock", "matching", "sokalsneath", "canberra", "hamming", "jaccard", "mahalanobis", "correlation", "seuclidean", "sokalmichener", "chebyshev", "sqeuclidean", "rogerstanimoto", "euclidean", "minkowski", "yule", "russellrao", "braycurtis"]}, "fields": []}, "type": "parameter", "description": "Metrics exposed by seaborn (see http://seaborn.pydata.org/generated/seaborn.clustermap.html#seaborn.clustermap for more detail).", "default": "braycurtis", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "method", "repr": "Choices('single', 'centroid', 'weighted', 'ward', 'complete', 'average', 'median')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["single", "centroid", "weighted", "ward", "complete", "average", "median"]}, "fields": []}, "type": "parameter", "description": "Clustering methods exposed by seaborn (see http://seaborn.pydata.org/generated/seaborn.clustermap.html#seaborn.clustermap for more detail).", "default": "average", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "cluster", "repr": "Choices('samples', 'features', 'both', 'none')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["samples", "features", "both", "none"]}, "fields": []}, "type": "parameter", "description": "Specify which axes to cluster.", "default": "features", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "color_scheme", "repr": "Choices('bwr_r', 'vlag_r', 'GnBu', 'PuBu', 'brg_r', 'gist_yarg_r', 'winter', 'OrRd_r', 'summer', 'CMRmap_r', 'RdGy', 'Purples', 'seismic_r', 'gist_gray_r', 'PuRd', 'flag_r', 'BuPu', 'spectral', 'PuRd_r', 'Oranges', 'coolwarm_r', 'RdYlBu', 'YlOrBr', 'CMRmap', 'Oranges_r', 'Set1_r', 'Set2', 'Vega10_r', 'binary', 'plasma', 'RdYlGn_r', 'terrain', 'gist_ncar', 'Vega10', 'pink_r', 'Wistia_r', 'PiYG_r', 'binary_r', 'cubehelix', 'YlGn_r', 'mako_r', 'Wistia', 'RdBu', 'prism', 'YlGn', 'icefire', 'PRGn', 'copper_r', 'YlGnBu_r', 'summer_r', 'RdPu_r', 'gist_yarg', 'Vega20b', 'prism_r', 'Greens', 'Spectral', 'YlOrRd', 'magma', 'bwr', 'ocean', 'gray', 'jet_r', 'seismic', 'gist_earth_r', 'pink', 'Set3', 'inferno_r', 'PRGn_r', 'gist_rainbow_r', 'BrBG_r', 'gist_heat_r', 'cividis', 'afmhot_r', 'bone', 'tab20_r', 'gnuplot2', 'hot_r', 'BrBG', 'copper', 'Paired', 'YlOrBr_r', 'Accent_r', 'Set3_r', 'cubehelix_r', 'Reds', 'PiYG', 'Vega20c', 'RdPu', 'YlGnBu', 'gist_rainbow', 'Set1', 'inferno', 'tab10_r', 'coolwarm', 'bone_r', 'Pastel2', 'icefire_r', 'rocket_r', 'BuPu_r', 'tab20b_r', 'gist_heat', 'Vega20', 'Reds_r', 'flag', 'viridis', 'RdBu_r', 'rainbow', 'magma_r', 'gnuplot_r', 'Blues_r', 'BuGn_r', 'cividis_r', 'ocean_r', 'Pastel1', 'spectral_r', 'gist_stern_r', 'hsv_r', 'mako', 'gist_ncar_r', 'jet', 'Greys_r', 'rocket', 'GnBu_r', 'gist_earth', 'hsv', 'Accent', 'Dark2_r', 'Greens_r', 'brg', 'nipy_spectral_r', 'PuOr_r', 'tab20c', 'tab10', 'winter_r', 'RdYlBu_r', 'Set2_r', 'gnuplot', 'PuBuGn_r', 'plasma_r', 'spring_r', 'RdGy_r', 'YlOrRd_r', 'tab20', 'tab20b', 'tab20c_r', 'autumn', 'Greys', 'Pastel1_r', 'gnuplot2_r', 'PuBuGn', 'Blues', 'Dark2', 'cool_r', 'gist_stern', 'rainbow_r', 'autumn_r', 'gist_gray', 'BuGn', 'Spectral_r', 'OrRd', 'Vega20c_r', 'nipy_spectral', 'Pastel2_r', 'Vega20_r', 'afmhot', 'Vega20b_r', 'Purples_r', 'cool', 'gray_r', 'vlag', 'spring', 'RdYlGn', 'hot', 'Paired_r', 'terrain_r', 'PuOr', 'viridis_r', 'PuBu_r')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["bwr_r", "vlag_r", "GnBu", "PuBu", "brg_r", "gist_yarg_r", "winter", "OrRd_r", "summer", "CMRmap_r", "RdGy", "Purples", "seismic_r", "gist_gray_r", "PuRd", "flag_r", "BuPu", "spectral", "PuRd_r", "Oranges", "coolwarm_r", "RdYlBu", "YlOrBr", "CMRmap", "Oranges_r", "Set1_r", "Set2", "Vega10_r", "binary", "plasma", "RdYlGn_r", "terrain", "gist_ncar", "Vega10", "pink_r", "Wistia_r", "PiYG_r", "binary_r", "cubehelix", "YlGn_r", "mako_r", "Wistia", "RdBu", "prism", "YlGn", "icefire", "PRGn", "copper_r", "YlGnBu_r", "summer_r", "RdPu_r", "gist_yarg", "Vega20b", "prism_r", "Greens", "Spectral", "YlOrRd", "magma", "bwr", "ocean", "gray", "jet_r", "seismic", "gist_earth_r", "pink", "Set3", "inferno_r", "PRGn_r", "gist_rainbow_r", "BrBG_r", "gist_heat_r", "cividis", "afmhot_r", "bone", "tab20_r", "gnuplot2", "hot_r", "BrBG", "copper", "Paired", "YlOrBr_r", "Accent_r", "Set3_r", "cubehelix_r", "Reds", "PiYG", "Vega20c", "RdPu", "YlGnBu", "gist_rainbow", "Set1", "inferno", "tab10_r", "coolwarm", "bone_r", "Pastel2", "icefire_r", "rocket_r", "BuPu_r", "tab20b_r", "gist_heat", "Vega20", "Reds_r", "flag", "viridis", "RdBu_r", "rainbow", "magma_r", "gnuplot_r", "Blues_r", "BuGn_r", "cividis_r", "ocean_r", "Pastel1", "spectral_r", "gist_stern_r", "hsv_r", "mako", "gist_ncar_r", "jet", "Greys_r", "rocket", "GnBu_r", "gist_earth", "hsv", "Accent", "Dark2_r", "Greens_r", "brg", "nipy_spectral_r", "PuOr_r", "tab20c", "tab10", "winter_r", "RdYlBu_r", "Set2_r", "gnuplot", "PuBuGn_r", "plasma_r", "spring_r", "RdGy_r", "YlOrRd_r", "tab20", "tab20b", "tab20c_r", "autumn", "Greys", "Pastel1_r", "gnuplot2_r", "PuBuGn", "Blues", "Dark2", "cool_r", "gist_stern", "rainbow_r", "autumn_r", "gist_gray", "BuGn", "Spectral_r", "OrRd", "Vega20c_r", "nipy_spectral", "Pastel2_r", "Vega20_r", "afmhot", "Vega20b_r", "Purples_r", "cool", "gray_r", "vlag", "spring", "RdYlGn", "hot", "Paired_r", "terrain_r", "PuOr", "viridis_r", "PuBu_r"]}, "fields": []}, "type": "parameter", "description": "Color scheme for heatmap.", "default": "rocket", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "heatmap", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Heatmap of important features.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "filtered_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "Filtered feature table containing data displayed in heatmap.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "quality-filter": {"id": "quality_filter", "name": "quality-filter", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-quality-filter", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin supports filtering and trimming of sequence reads based on PHRED scores and ambiguous nucleotide characters.", "short_description": "Plugin for PHRED-based filtering and trimming.", "actions": {"q_score": {"id": "q_score", "name": "Quality filter based on sequence quality scores.", "description": "This method filters sequence based on quality scores and the presence of ambiguous base calls.", "signature": [{"name": "demux", "repr": "SampleData[SequencesWithQuality | PairedEndSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The demultiplexed sequence data to be quality filtered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_quality", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The minimum acceptable PHRED score. All PHRED scores less that this value are considered to be low PHRED scores.", "default": 4, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "quality_window", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The maximum number of low PHRED scores that can be observed in direct succession before truncating a sequence read.", "default": 3, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_length_fraction", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The minimum length that a sequence read can be following truncation and still be retained. This length should be provided as a fraction of the input sequence length.", "default": 0.75, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_ambiguous", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The maximum number of ambiguous (i.e., N) base calls. This is applied after trimming sequences based on `min_length_fraction`.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "filtered_sequences", "repr": "SampleData[SequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting quality-filtered sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "filter_stats", "repr": "QualityFilterStats", "ast": {"type": "expression", "builtin": false, "name": "QualityFilterStats", "predicate": null, "fields": []}, "type": "output", "description": "Summary statistics of the filtering process.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "q_score_joined": {"id": "q_score_joined", "name": "Quality filter based on joined sequence quality scores.", "description": "This method filters joined sequence based on quality scores and the presence of ambiguous base calls.", "signature": [{"name": "demux", "repr": "SampleData[JoinedSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "JoinedSequencesWithQuality", "predicate": null, "fields": []}]}, "type": "input", "description": "The demultiplexed sequence data to be quality filtered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_quality", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The minimum acceptable PHRED score. All PHRED scores less that this value are considered to be low PHRED scores.", "default": 4, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "quality_window", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The maximum number of low PHRED scores that can be observed in direct succession before truncating a sequence read.", "default": 3, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_length_fraction", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The minimum length that a sequence read can be following truncation and still be retained. This length should be provided as a fraction of the input sequence length.", "default": 0.75, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_ambiguous", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The maximum number of ambiguous (i.e., N) base calls. This is applied after trimming sequences based on `min_length_fraction`.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "filtered_sequences", "repr": "SampleData[JoinedSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "JoinedSequencesWithQuality", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting quality-filtered sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "filter_stats", "repr": "QualityFilterStats", "ast": {"type": "expression", "builtin": false, "name": "QualityFilterStats", "predicate": null, "fields": []}, "type": "output", "description": "Summary statistics of the filtering process.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "quality-control": {"id": "quality_control", "name": "quality-control", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-quality-control", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin supports methods for assessing and controlling the quality of feature and sequence data.", "short_description": "Plugin for quality control of feature and sequence data.", "actions": {"exclude_seqs": {"id": "exclude_seqs", "name": "Exclude sequences by alignment", "description": "This method aligns feature sequences to a set of reference sequences to identify sequences that hit/miss the reference within a specified perc_identity, evalue, and perc_query_aligned. This method could be used to define a positive filter, e.g., extract only feature sequences that align to a certain clade of bacteria; or to define a negative filter, e.g., identify sequences that align to contaminant or human DNA sequences that should be excluded from subsequent analyses. Note that filtering is performed based on the perc_identity, perc_query_aligned, and evalue thresholds (the latter only if method==BLAST and an evalue is set). Set perc_identity==0 and/or perc_query_aligned==0 to disable these filtering thresholds as necessary.", "signature": [{"name": "query_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Sequences to test for exclusion", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Reference sequences to align against feature sequences", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "method", "repr": "Choices('blast', 'vsearch', 'blastn-short')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["blast", "vsearch", "blastn-short"]}, "fields": []}, "type": "parameter", "description": "Alignment method to use for matching feature sequences against reference sequences", "default": "blast", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "perc_identity", "repr": "Range(0.0, 1.0, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "Reject match if percent identity to reference is lower. Must be in range [0.0, 1.0]", "default": 0.97, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "evalue", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "BLAST expectation (E) value threshold for saving hits. Reject if E value is higher than threshold. This threshold is disabled by default.", "default": null, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "perc_query_aligned", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "Percent of query sequence that must align to reference in order to be accepted as a hit.", "default": 0.97, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "threads", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of jobs to execute. Only applies to vsearch method.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sequence_hits", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "Subset of feature sequences that align to reference sequences", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sequence_misses", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "Subset of feature sequences that do not align to reference sequences", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "evaluate_composition": {"id": "evaluate_composition", "name": "Evaluate expected vs. observed taxonomic composition of samples", "description": "This visualizer compares the feature composition of pairs of observed and expected samples containing the same sample ID in two separate feature tables. Typically, feature composition will consist of taxonomy classifications or other semicolon-delimited feature annotations. Taxon accuracy rate, taxon detection rate, and linear regression scores between expected and observed observations are calculated at each semicolon-delimited rank, and plots of per-level accuracy and observation correlations are plotted. A histogram of distance between false positive observations and the nearest expected feature is also generated, where distance equals the number of rank differences between the observed feature and the nearest common lineage in the expected feature. This visualizer is most suitable for testing per-run data quality on sequencing runs that contain mock communities or other samples with known composition. Also suitable for sanity checks of bioinformatics pipeline performance.", "signature": [{"name": "expected_features", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Expected feature compositions", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "observed_features", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Observed feature compositions", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "depth", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Maximum depth of semicolon-delimited taxonomic ranks to test (e.g., 1 = root, 7 = species for the greengenes reference sequence database).", "default": 7, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "palette", "repr": "Choices('Set1', 'Set2', 'Set3', 'Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', 'tab10', 'tab20', 'tab20b', 'tab20c', 'viridis', 'plasma', 'inferno', 'magma', 'terrain', 'rainbow')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["Set1", "Set2", "Set3", "Pastel1", "Pastel2", "Paired", "Accent", "Dark2", "tab10", "tab20", "tab20b", "tab20c", "viridis", "plasma", "inferno", "magma", "terrain", "rainbow"]}, "fields": []}, "type": "parameter", "description": "Color palette to utilize for plotting.", "default": "Set1", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "plot_tar", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Plot taxon accuracy rate (TAR) on score plot. TAR is the number of true positive features divided by the total number of observed features (TAR = true positives / (true positives + false positives)).", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "plot_tdr", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Plot taxon detection rate (TDR) on score plot. TDR is the number of true positive features divided by the total number of expected features (TDR = true positives / (true positives + false negatives)).", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "plot_r_value", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Plot expected vs. observed linear regression r value on score plot.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "plot_r_squared", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Plot expected vs. observed linear regression r-squared value on score plot.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "plot_bray_curtis", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Plot expected vs. observed Bray-Curtis dissimilarity scores on score plot.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "plot_jaccard", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Plot expected vs. observed Jaccard distances scores on score plot.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "plot_observed_features", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Plot observed features count on score plot.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "plot_observed_features_ratio", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Plot ratio of observed:expected features on score plot.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Optional sample metadata that maps observed_features sample IDs to expected_features sample IDs.", "default": null, "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "evaluate_seqs": {"id": "evaluate_seqs", "name": "Compare query (observed) vs. reference (expected) sequences.", "description": "This action aligns a set of query (e.g., observed) sequences against a set of reference (e.g., expected) sequences to evaluate the quality of alignment. The intended use is to align observed sequences against expected sequences (e.g., from a mock community) to determine the frequency of mismatches between observed sequences and the most similar expected sequences, e.g., as a measure of sequencing/method error. However, any sequences may be provided as input to generate a report on pairwise alignment quality against a set of reference sequences.", "signature": [{"name": "query_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Sequences to test for exclusion", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Reference sequences to align against feature sequences", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "show_alignments", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Option to plot pairwise alignments of query sequences and their top hits.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "evaluate_taxonomy": {"id": "evaluate_taxonomy", "name": "Evaluate expected vs. observed taxonomic assignments", "description": "This visualizer compares a pair of observed and expected taxonomic assignments to calculate precision, recall, and F-measure at each taxonomic level, up to maximum level specified by the depth parameter. These metrics are calculated at each semicolon-delimited rank. This action is useful for comparing the accuracy of taxonomic assignment, e.g., between different taxonomy classifiers or other bioinformatics methods. Expected taxonomies should be derived from simulated or mock community sequences that have known taxonomic affiliations.", "signature": [{"name": "expected_taxa", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "description": "Expected taxonomic assignments", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "observed_taxa", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "description": "Observed taxonomic assignments", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "depth", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Maximum depth of semicolon-delimited taxonomic ranks to test (e.g., 1 = root, 7 = species for the greengenes reference sequence database).", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "palette", "repr": "Choices('Set1', 'Set2', 'Set3', 'Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', 'tab10', 'tab20', 'tab20b', 'tab20c', 'viridis', 'plasma', 'inferno', 'magma', 'terrain', 'rainbow')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["Set1", "Set2", "Set3", "Pastel1", "Pastel2", "Paired", "Accent", "Dark2", "tab10", "tab20", "tab20b", "tab20c", "viridis", "plasma", "inferno", "magma", "terrain", "rainbow"]}, "fields": []}, "type": "parameter", "description": "Color palette to utilize for plotting.", "default": "Set1", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "require_exp_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Require that all features found in observed taxa must be found in expected taxa or raise error.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "require_obs_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Require that all features found in expected taxa must be found in observed taxa or raise error.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "feature_table", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Optional feature table containing relative frequency of each feature, used to weight accuracy scores by frequency. Must contain all features found in expected and/or observed taxa. Features found in the table but not the expected/observed taxa will be dropped prior to analysis.", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_id", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Optional sample ID to use for extracting frequency data from feature table, and for labeling accuracy results. If no sample_id is provided, feature frequencies are derived from the sum of all samples present in the feature table.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "phylogeny": {"id": "phylogeny", "name": "phylogeny", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-phylogeny", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin supports generating and manipulating phylogenetic trees.", "short_description": "Plugin for generating and manipulating phylogenies.", "actions": {"midpoint_root": {"id": "midpoint_root", "name": "Midpoint root an unrooted phylogenetic tree.", "description": "Midpoint root an unrooted phylogenetic tree.", "signature": [{"name": "tree", "repr": "Phylogeny[Unrooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Unrooted", "predicate": null, "fields": []}]}, "type": "input", "description": "The phylogenetic tree to be rooted.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "rooted_tree", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "output", "description": "The rooted phylogenetic tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "fasttree": {"id": "fasttree", "name": "Construct a phylogenetic tree with FastTree.", "description": "Construct a phylogenetic tree with FastTree.", "signature": [{"name": "alignment", "repr": "FeatureData[AlignedSequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlignedSequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Aligned sequences to be used for phylogenetic reconstruction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_threads", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of threads. Using more than one thread runs the non-deterministic variant of `FastTree` (`FastTreeMP`), and may result in a different tree than single-threading. See http://www.microbesonline.org/fasttree/#OpenMP for details. (Use 0 to automatically use all available cores)", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Phylogeny[Unrooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Unrooted", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting phylogenetic tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "raxml": {"id": "raxml", "name": "Construct a phylogenetic tree with RAxML.", "description": "Construct a phylogenetic tree with RAxML. See: https://sco.h-its.org/exelixis/web/software/raxml/", "signature": [{"name": "alignment", "repr": "FeatureData[AlignedSequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlignedSequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Aligned sequences to be used for phylogenetic reconstruction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "seed", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Random number seed for the parsimony starting tree. This allows you to reproduce tree results. If not supplied then one will be randomly chosen.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_searches", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of independent maximum likelihood searches to perform. The single best scoring tree is returned.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_threads", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of threads to use for multithreaded processing. Using more than one thread will enable the PTHREADS version of RAxML.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "raxml_version", "repr": "Choices('Standard', 'SSE3', 'AVX2')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["Standard", "SSE3", "AVX2"]}, "fields": []}, "type": "parameter", "description": "Select a specific CPU optimization of RAxML to use. The SSE3 versions will run approximately 40% faster than the standard version. The AVX2 version will run 10-30% faster than the SSE3 version.", "default": "Standard", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "substitution_model", "repr": "Choices('GTRGAMMA', 'GTRGAMMAI', 'GTRCAT', 'GTRCATI')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["GTRGAMMA", "GTRGAMMAI", "GTRCAT", "GTRCATI"]}, "fields": []}, "type": "parameter", "description": "Model of Nucleotide Substitution.", "default": "GTRGAMMA", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Phylogeny[Unrooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Unrooted", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting phylogenetic tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "raxml_rapid_bootstrap": {"id": "raxml_rapid_bootstrap", "name": "Construct a phylogenetic tree with bootstrap supports using RAxML.", "description": "Construct a phylogenetic tree with RAxML with the addition of rapid bootstrapping support values. See: https://sco.h-its.org/exelixis/web/software/raxml/", "signature": [{"name": "alignment", "repr": "FeatureData[AlignedSequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlignedSequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Aligned sequences to be used for phylogenetic reconstruction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "seed", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Random number seed for the parsimony starting tree. This allows you to reproduce tree results. If not supplied then one will be randomly chosen.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "rapid_bootstrap_seed", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Specify\u00a0a random\u00a0seed for rapid\u00a0bootstrapping. This allows you to reproduce rapid bootstrap results. If not supplied then one will be randomly chosen.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "bootstrap_replicates", "repr": "Range(10, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [10, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of bootstrap searches to perform.", "default": 100, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_threads", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of threads to use for multithreaded processing. Using more than one thread will enable the PTHREADS version of RAxML.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "raxml_version", "repr": "Choices('Standard', 'SSE3', 'AVX2')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["Standard", "SSE3", "AVX2"]}, "fields": []}, "type": "parameter", "description": "Select a specific CPU optimization of RAxML to use. The SSE3 versions will run approximately 40% faster than the standard version. The AVX2 version will run 10-30% faster than the SSE3 version.", "default": "Standard", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "substitution_model", "repr": "Choices('GTRGAMMA', 'GTRGAMMAI', 'GTRCAT', 'GTRCATI')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["GTRGAMMA", "GTRGAMMAI", "GTRCAT", "GTRCATI"]}, "fields": []}, "type": "parameter", "description": "Model of Nucleotide Substitution", "default": "GTRGAMMA", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Phylogeny[Unrooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Unrooted", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting phylogenetic tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "iqtree": {"id": "iqtree", "name": "Construct a phylogenetic tree with IQ-TREE.", "description": "Construct a phylogenetic tree using IQ-TREE (http://www.iqtree.org/) with automatic model selection.", "signature": [{"name": "alignment", "repr": "FeatureData[AlignedSequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlignedSequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Aligned sequences to be used for phylogenetic reconstruction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "seed", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Random number seed. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_cores", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of cores to use for parallel processing. Use '0' to let IQ-TREE automatically determine the optimal number of cores to use.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_runs", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of indepedent runs. Multiple  independent runs (e.g. 10) can outperform a single run in terms of likelihood maximisation.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "substitution_model", "repr": "Choices('JC', 'JC+I', 'JC+G', 'JC+I+G', 'JC+R2', 'JC+R3', 'JC+R4', 'JC+R5', 'JC+R6', 'JC+R7', 'JC+R8', 'JC+R9', 'JC+R10', 'F81', 'F81+I', 'F81+G', 'F81+I+G', 'F81+R2', 'F81+R3', 'F81+R4', 'F81+R5', 'F81+R6', 'F81+R7', 'F81+R8', 'F81+R9', 'F81+R10', 'K80', 'K80+I', 'K80+G', 'K80+I+G', 'K80+R2', 'K80+R3', 'K80+R4', 'K80+R5', 'K80+R6', 'K80+R7', 'K80+R8', 'K80+R9', 'K80+R10', 'HKY', 'HKY+I', 'HKY+G', 'HKY+I+G', 'HKY+R2', 'HKY+R3', 'HKY+R4', 'HKY+R5', 'HKY+R6', 'HKY+R7', 'HKY+R8', 'HKY+R9', 'HKY+R10', 'TNe', 'TNe+I', 'TNe+G', 'TNe+I+G', 'TNe+R2', 'TNe+R3', 'TNe+R4', 'TNe+R5', 'TNe+R6', 'TNe+R7', 'TNe+R8', 'TNe+R9', 'TNe+R10', 'TN', 'TN+I', 'TN+G', 'TN+I+G', 'TN+R2', 'TN+R3', 'TN+R4', 'TN+R5', 'TN+R6', 'TN+R7', 'TN+R8', 'TN+R9', 'TN+R10', 'K81', 'K81+I', 'K81+G', 'K81+I+G', 'K81+R2', 'K81+R3', 'K81+R4', 'K81+R5', 'K81+R6', 'K81+R7', 'K81+R8', 'K81+R9', 'K81+R10', 'K81u', 'K81u+I', 'K81u+G', 'K81u+I+G', 'K81u+R2', 'K81u+R3', 'K81u+R4', 'K81u+R5', 'K81u+R6', 'K81u+R7', 'K81u+R8', 'K81u+R9', 'K81u+R10', 'TPM2', 'TPM2+I', 'TPM2+G', 'TPM2+I+G', 'TPM2+R2', 'TPM2+R3', 'TPM2+R4', 'TPM2+R5', 'TPM2+R6', 'TPM2+R7', 'TPM2+R8', 'TPM2+R9', 'TPM2+R10', 'TPM2u', 'TPM2u+I', 'TPM2u+G', 'TPM2u+I+G', 'TPM2u+R2', 'TPM2u+R3', 'TPM2u+R4', 'TPM2u+R5', 'TPM2u+R6', 'TPM2u+R7', 'TPM2u+R8', 'TPM2u+R9', 'TPM2u+R10', 'TPM3', 'TPM3+I', 'TPM3+G', 'TPM3+I+G', 'TPM3+R2', 'TPM3+R3', 'TPM3+R4', 'TPM3+R5', 'TPM3+R6', 'TPM3+R7', 'TPM3+R8', 'TPM3+R9', 'TPM3+R10', 'TPM3u', 'TPM3u+I', 'TPM3u+G', 'TPM3u+I+G', 'TPM3u+R2', 'TPM3u+R3', 'TPM3u+R4', 'TPM3u+R5', 'TPM3u+R6', 'TPM3u+R7', 'TPM3u+R8', 'TPM3u+R9', 'TPM3u+R10', 'TIMe', 'TIMe+I', 'TIMe+G', 'TIMe+I+G', 'TIMe+R2', 'TIMe+R3', 'TIMe+R4', 'TIMe+R5', 'TIMe+R6', 'TIMe+R7', 'TIMe+R8', 'TIMe+R9', 'TIMe+R10', 'TIM', 'TIM+I', 'TIM+G', 'TIM+I+G', 'TIM+R2', 'TIM+R3', 'TIM+R4', 'TIM+R5', 'TIM+R6', 'TIM+R7', 'TIM+R8', 'TIM+R9', 'TIM+R10', 'TIM2e', 'TIM2e+I', 'TIM2e+G', 'TIM2e+I+G', 'TIM2e+R2', 'TIM2e+R3', 'TIM2e+R4', 'TIM2e+R5', 'TIM2e+R6', 'TIM2e+R7', 'TIM2e+R8', 'TIM2e+R9', 'TIM2e+R10', 'TIM2', 'TIM2+I', 'TIM2+G', 'TIM2+I+G', 'TIM2+R2', 'TIM2+R3', 'TIM2+R4', 'TIM2+R5', 'TIM2+R6', 'TIM2+R7', 'TIM2+R8', 'TIM2+R9', 'TIM2+R10', 'TIM3e', 'TIM3e+I', 'TIM3e+G', 'TIM3e+I+G', 'TIM3e+R2', 'TIM3e+R3', 'TIM3e+R4', 'TIM3e+R5', 'TIM3e+R6', 'TIM3e+R7', 'TIM3e+R8', 'TIM3e+R9', 'TIM3e+R10', 'TIM3', 'TIM3+I', 'TIM3+G', 'TIM3+I+G', 'TIM3+R2', 'TIM3+R3', 'TIM3+R4', 'TIM3+R5', 'TIM3+R6', 'TIM3+R7', 'TIM3+R8', 'TIM3+R9', 'TIM3+R10', 'TVMe', 'TVMe+I', 'TVMe+G', 'TVMe+I+G', 'TVMe+R2', 'TVMe+R3', 'TVMe+R4', 'TVMe+R5', 'TVMe+R6', 'TVMe+R7', 'TVMe+R8', 'TVMe+R9', 'TVMe+R10', 'TVM', 'TVM+I', 'TVM+G', 'TVM+I+G', 'TVM+R2', 'TVM+R3', 'TVM+R4', 'TVM+R5', 'TVM+R6', 'TVM+R7', 'TVM+R8', 'TVM+R9', 'TVM+R10', 'SYM', 'SYM+I', 'SYM+G', 'SYM+I+G', 'SYM+R2', 'SYM+R3', 'SYM+R4', 'SYM+R5', 'SYM+R6', 'SYM+R7', 'SYM+R8', 'SYM+R9', 'SYM+R10', 'GTR', 'GTR+I', 'GTR+G', 'GTR+I+G', 'GTR+R2', 'GTR+R3', 'GTR+R4', 'GTR+R5', 'GTR+R6', 'GTR+R7', 'GTR+R8', 'GTR+R9', 'GTR+R10', 'MFP', 'TEST')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["JC", "JC+I", "JC+G", "JC+I+G", "JC+R2", "JC+R3", "JC+R4", "JC+R5", "JC+R6", "JC+R7", "JC+R8", "JC+R9", "JC+R10", "F81", "F81+I", "F81+G", "F81+I+G", "F81+R2", "F81+R3", "F81+R4", "F81+R5", "F81+R6", "F81+R7", "F81+R8", "F81+R9", "F81+R10", "K80", "K80+I", "K80+G", "K80+I+G", "K80+R2", "K80+R3", "K80+R4", "K80+R5", "K80+R6", "K80+R7", "K80+R8", "K80+R9", "K80+R10", "HKY", "HKY+I", "HKY+G", "HKY+I+G", "HKY+R2", "HKY+R3", "HKY+R4", "HKY+R5", "HKY+R6", "HKY+R7", "HKY+R8", "HKY+R9", "HKY+R10", "TNe", "TNe+I", "TNe+G", "TNe+I+G", "TNe+R2", "TNe+R3", "TNe+R4", "TNe+R5", "TNe+R6", "TNe+R7", "TNe+R8", "TNe+R9", "TNe+R10", "TN", "TN+I", "TN+G", "TN+I+G", "TN+R2", "TN+R3", "TN+R4", "TN+R5", "TN+R6", "TN+R7", "TN+R8", "TN+R9", "TN+R10", "K81", "K81+I", "K81+G", "K81+I+G", "K81+R2", "K81+R3", "K81+R4", "K81+R5", "K81+R6", "K81+R7", "K81+R8", "K81+R9", "K81+R10", "K81u", "K81u+I", "K81u+G", "K81u+I+G", "K81u+R2", "K81u+R3", "K81u+R4", "K81u+R5", "K81u+R6", "K81u+R7", "K81u+R8", "K81u+R9", "K81u+R10", "TPM2", "TPM2+I", "TPM2+G", "TPM2+I+G", "TPM2+R2", "TPM2+R3", "TPM2+R4", "TPM2+R5", "TPM2+R6", "TPM2+R7", "TPM2+R8", "TPM2+R9", "TPM2+R10", "TPM2u", "TPM2u+I", "TPM2u+G", "TPM2u+I+G", "TPM2u+R2", "TPM2u+R3", "TPM2u+R4", "TPM2u+R5", "TPM2u+R6", "TPM2u+R7", "TPM2u+R8", "TPM2u+R9", "TPM2u+R10", "TPM3", "TPM3+I", "TPM3+G", "TPM3+I+G", "TPM3+R2", "TPM3+R3", "TPM3+R4", "TPM3+R5", "TPM3+R6", "TPM3+R7", "TPM3+R8", "TPM3+R9", "TPM3+R10", "TPM3u", "TPM3u+I", "TPM3u+G", "TPM3u+I+G", "TPM3u+R2", "TPM3u+R3", "TPM3u+R4", "TPM3u+R5", "TPM3u+R6", "TPM3u+R7", "TPM3u+R8", "TPM3u+R9", "TPM3u+R10", "TIMe", "TIMe+I", "TIMe+G", "TIMe+I+G", "TIMe+R2", "TIMe+R3", "TIMe+R4", "TIMe+R5", "TIMe+R6", "TIMe+R7", "TIMe+R8", "TIMe+R9", "TIMe+R10", "TIM", "TIM+I", "TIM+G", "TIM+I+G", "TIM+R2", "TIM+R3", "TIM+R4", "TIM+R5", "TIM+R6", "TIM+R7", "TIM+R8", "TIM+R9", "TIM+R10", "TIM2e", "TIM2e+I", "TIM2e+G", "TIM2e+I+G", "TIM2e+R2", "TIM2e+R3", "TIM2e+R4", "TIM2e+R5", "TIM2e+R6", "TIM2e+R7", "TIM2e+R8", "TIM2e+R9", "TIM2e+R10", "TIM2", "TIM2+I", "TIM2+G", "TIM2+I+G", "TIM2+R2", "TIM2+R3", "TIM2+R4", "TIM2+R5", "TIM2+R6", "TIM2+R7", "TIM2+R8", "TIM2+R9", "TIM2+R10", "TIM3e", "TIM3e+I", "TIM3e+G", "TIM3e+I+G", "TIM3e+R2", "TIM3e+R3", "TIM3e+R4", "TIM3e+R5", "TIM3e+R6", "TIM3e+R7", "TIM3e+R8", "TIM3e+R9", "TIM3e+R10", "TIM3", "TIM3+I", "TIM3+G", "TIM3+I+G", "TIM3+R2", "TIM3+R3", "TIM3+R4", "TIM3+R5", "TIM3+R6", "TIM3+R7", "TIM3+R8", "TIM3+R9", "TIM3+R10", "TVMe", "TVMe+I", "TVMe+G", "TVMe+I+G", "TVMe+R2", "TVMe+R3", "TVMe+R4", "TVMe+R5", "TVMe+R6", "TVMe+R7", "TVMe+R8", "TVMe+R9", "TVMe+R10", "TVM", "TVM+I", "TVM+G", "TVM+I+G", "TVM+R2", "TVM+R3", "TVM+R4", "TVM+R5", "TVM+R6", "TVM+R7", "TVM+R8", "TVM+R9", "TVM+R10", "SYM", "SYM+I", "SYM+G", "SYM+I+G", "SYM+R2", "SYM+R3", "SYM+R4", "SYM+R5", "SYM+R6", "SYM+R7", "SYM+R8", "SYM+R9", "SYM+R10", "GTR", "GTR+I", "GTR+G", "GTR+I+G", "GTR+R2", "GTR+R3", "GTR+R4", "GTR+R5", "GTR+R6", "GTR+R7", "GTR+R8", "GTR+R9", "GTR+R10", "MFP", "TEST"]}, "fields": []}, "type": "parameter", "description": "Model of Nucleotide Substitution. If not provided, IQ-TREE will determine the best fit substitution model automatically.", "default": "MFP", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_init_pars_trees", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of initial parsimony trees. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_top_init_trees", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of top initial trees. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_best_retain_trees", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of best trees retained during search. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_iter", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Fix number of iterations to stop. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "stop_iter", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of unsuccessful iterations to stop. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "perturb_nni_strength", "repr": "Range(0.01, 99)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.01, 99], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Perturbation strength for randomized NNI. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "spr_radius", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Radius for parsimony SPR search. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "allnni", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Perform more thorough NNI search.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "fast", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Fast search to resemble FastTree.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "alrt", "repr": "Range(1000, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1000, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Single branch test method. Number of bootstrap replicates to perform an SH-like approximate likelihood ratio test (SH-aLRT). Minimum of 1000 replicates is recomended. Set to '0' for parametric aLRT test. Can be used with other 'single branch test methods'. Values reported in the order of: alrt, lbp, abayes.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "abayes", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Single branch test method. Approximate Bayes test. Can be used with other 'single branch test methods'. Values reported in the order of: alrt, lbp, abayes.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "lbp", "repr": "Range(1000, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1000, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Single branch test method. Number of bootstrap replicates to perform a fast local bootstrap probability method. Minimum of 1000 replicates is recomended. Can be used with other 'single branch test methods'. Values reported in the order of: alrt, lbp, abayes.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "safe", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Safe likelihood kernel to avoid numerical underflow.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "tree", "repr": "Phylogeny[Unrooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Unrooted", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting phylogenetic tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "iqtree_ultrafast_bootstrap": {"id": "iqtree_ultrafast_bootstrap", "name": "Construct a phylogenetic tree with IQ-TREE with bootstrap supports.", "description": "Construct a phylogenetic tree using IQ-TREE (http://www.iqtree.org/) with automatic model selection and bootstrap supports.", "signature": [{"name": "alignment", "repr": "FeatureData[AlignedSequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlignedSequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Aligned sequences to be used for phylogenetic reconstruction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "seed", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Random number seed. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_cores", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of cores to use for parallel processing. Use '0' to let IQ-TREE automatically determine the optimal number of cores to use.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_runs", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of indepedent runs. Multiple  independent runs (e.g. 10) can outperform a single run in terms of likelihood maximisation.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "substitution_model", "repr": "Choices('JC', 'JC+I', 'JC+G', 'JC+I+G', 'JC+R2', 'JC+R3', 'JC+R4', 'JC+R5', 'JC+R6', 'JC+R7', 'JC+R8', 'JC+R9', 'JC+R10', 'F81', 'F81+I', 'F81+G', 'F81+I+G', 'F81+R2', 'F81+R3', 'F81+R4', 'F81+R5', 'F81+R6', 'F81+R7', 'F81+R8', 'F81+R9', 'F81+R10', 'K80', 'K80+I', 'K80+G', 'K80+I+G', 'K80+R2', 'K80+R3', 'K80+R4', 'K80+R5', 'K80+R6', 'K80+R7', 'K80+R8', 'K80+R9', 'K80+R10', 'HKY', 'HKY+I', 'HKY+G', 'HKY+I+G', 'HKY+R2', 'HKY+R3', 'HKY+R4', 'HKY+R5', 'HKY+R6', 'HKY+R7', 'HKY+R8', 'HKY+R9', 'HKY+R10', 'TNe', 'TNe+I', 'TNe+G', 'TNe+I+G', 'TNe+R2', 'TNe+R3', 'TNe+R4', 'TNe+R5', 'TNe+R6', 'TNe+R7', 'TNe+R8', 'TNe+R9', 'TNe+R10', 'TN', 'TN+I', 'TN+G', 'TN+I+G', 'TN+R2', 'TN+R3', 'TN+R4', 'TN+R5', 'TN+R6', 'TN+R7', 'TN+R8', 'TN+R9', 'TN+R10', 'K81', 'K81+I', 'K81+G', 'K81+I+G', 'K81+R2', 'K81+R3', 'K81+R4', 'K81+R5', 'K81+R6', 'K81+R7', 'K81+R8', 'K81+R9', 'K81+R10', 'K81u', 'K81u+I', 'K81u+G', 'K81u+I+G', 'K81u+R2', 'K81u+R3', 'K81u+R4', 'K81u+R5', 'K81u+R6', 'K81u+R7', 'K81u+R8', 'K81u+R9', 'K81u+R10', 'TPM2', 'TPM2+I', 'TPM2+G', 'TPM2+I+G', 'TPM2+R2', 'TPM2+R3', 'TPM2+R4', 'TPM2+R5', 'TPM2+R6', 'TPM2+R7', 'TPM2+R8', 'TPM2+R9', 'TPM2+R10', 'TPM2u', 'TPM2u+I', 'TPM2u+G', 'TPM2u+I+G', 'TPM2u+R2', 'TPM2u+R3', 'TPM2u+R4', 'TPM2u+R5', 'TPM2u+R6', 'TPM2u+R7', 'TPM2u+R8', 'TPM2u+R9', 'TPM2u+R10', 'TPM3', 'TPM3+I', 'TPM3+G', 'TPM3+I+G', 'TPM3+R2', 'TPM3+R3', 'TPM3+R4', 'TPM3+R5', 'TPM3+R6', 'TPM3+R7', 'TPM3+R8', 'TPM3+R9', 'TPM3+R10', 'TPM3u', 'TPM3u+I', 'TPM3u+G', 'TPM3u+I+G', 'TPM3u+R2', 'TPM3u+R3', 'TPM3u+R4', 'TPM3u+R5', 'TPM3u+R6', 'TPM3u+R7', 'TPM3u+R8', 'TPM3u+R9', 'TPM3u+R10', 'TIMe', 'TIMe+I', 'TIMe+G', 'TIMe+I+G', 'TIMe+R2', 'TIMe+R3', 'TIMe+R4', 'TIMe+R5', 'TIMe+R6', 'TIMe+R7', 'TIMe+R8', 'TIMe+R9', 'TIMe+R10', 'TIM', 'TIM+I', 'TIM+G', 'TIM+I+G', 'TIM+R2', 'TIM+R3', 'TIM+R4', 'TIM+R5', 'TIM+R6', 'TIM+R7', 'TIM+R8', 'TIM+R9', 'TIM+R10', 'TIM2e', 'TIM2e+I', 'TIM2e+G', 'TIM2e+I+G', 'TIM2e+R2', 'TIM2e+R3', 'TIM2e+R4', 'TIM2e+R5', 'TIM2e+R6', 'TIM2e+R7', 'TIM2e+R8', 'TIM2e+R9', 'TIM2e+R10', 'TIM2', 'TIM2+I', 'TIM2+G', 'TIM2+I+G', 'TIM2+R2', 'TIM2+R3', 'TIM2+R4', 'TIM2+R5', 'TIM2+R6', 'TIM2+R7', 'TIM2+R8', 'TIM2+R9', 'TIM2+R10', 'TIM3e', 'TIM3e+I', 'TIM3e+G', 'TIM3e+I+G', 'TIM3e+R2', 'TIM3e+R3', 'TIM3e+R4', 'TIM3e+R5', 'TIM3e+R6', 'TIM3e+R7', 'TIM3e+R8', 'TIM3e+R9', 'TIM3e+R10', 'TIM3', 'TIM3+I', 'TIM3+G', 'TIM3+I+G', 'TIM3+R2', 'TIM3+R3', 'TIM3+R4', 'TIM3+R5', 'TIM3+R6', 'TIM3+R7', 'TIM3+R8', 'TIM3+R9', 'TIM3+R10', 'TVMe', 'TVMe+I', 'TVMe+G', 'TVMe+I+G', 'TVMe+R2', 'TVMe+R3', 'TVMe+R4', 'TVMe+R5', 'TVMe+R6', 'TVMe+R7', 'TVMe+R8', 'TVMe+R9', 'TVMe+R10', 'TVM', 'TVM+I', 'TVM+G', 'TVM+I+G', 'TVM+R2', 'TVM+R3', 'TVM+R4', 'TVM+R5', 'TVM+R6', 'TVM+R7', 'TVM+R8', 'TVM+R9', 'TVM+R10', 'SYM', 'SYM+I', 'SYM+G', 'SYM+I+G', 'SYM+R2', 'SYM+R3', 'SYM+R4', 'SYM+R5', 'SYM+R6', 'SYM+R7', 'SYM+R8', 'SYM+R9', 'SYM+R10', 'GTR', 'GTR+I', 'GTR+G', 'GTR+I+G', 'GTR+R2', 'GTR+R3', 'GTR+R4', 'GTR+R5', 'GTR+R6', 'GTR+R7', 'GTR+R8', 'GTR+R9', 'GTR+R10', 'MFP', 'TEST')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["JC", "JC+I", "JC+G", "JC+I+G", "JC+R2", "JC+R3", "JC+R4", "JC+R5", "JC+R6", "JC+R7", "JC+R8", "JC+R9", "JC+R10", "F81", "F81+I", "F81+G", "F81+I+G", "F81+R2", "F81+R3", "F81+R4", "F81+R5", "F81+R6", "F81+R7", "F81+R8", "F81+R9", "F81+R10", "K80", "K80+I", "K80+G", "K80+I+G", "K80+R2", "K80+R3", "K80+R4", "K80+R5", "K80+R6", "K80+R7", "K80+R8", "K80+R9", "K80+R10", "HKY", "HKY+I", "HKY+G", "HKY+I+G", "HKY+R2", "HKY+R3", "HKY+R4", "HKY+R5", "HKY+R6", "HKY+R7", "HKY+R8", "HKY+R9", "HKY+R10", "TNe", "TNe+I", "TNe+G", "TNe+I+G", "TNe+R2", "TNe+R3", "TNe+R4", "TNe+R5", "TNe+R6", "TNe+R7", "TNe+R8", "TNe+R9", "TNe+R10", "TN", "TN+I", "TN+G", "TN+I+G", "TN+R2", "TN+R3", "TN+R4", "TN+R5", "TN+R6", "TN+R7", "TN+R8", "TN+R9", "TN+R10", "K81", "K81+I", "K81+G", "K81+I+G", "K81+R2", "K81+R3", "K81+R4", "K81+R5", "K81+R6", "K81+R7", "K81+R8", "K81+R9", "K81+R10", "K81u", "K81u+I", "K81u+G", "K81u+I+G", "K81u+R2", "K81u+R3", "K81u+R4", "K81u+R5", "K81u+R6", "K81u+R7", "K81u+R8", "K81u+R9", "K81u+R10", "TPM2", "TPM2+I", "TPM2+G", "TPM2+I+G", "TPM2+R2", "TPM2+R3", "TPM2+R4", "TPM2+R5", "TPM2+R6", "TPM2+R7", "TPM2+R8", "TPM2+R9", "TPM2+R10", "TPM2u", "TPM2u+I", "TPM2u+G", "TPM2u+I+G", "TPM2u+R2", "TPM2u+R3", "TPM2u+R4", "TPM2u+R5", "TPM2u+R6", "TPM2u+R7", "TPM2u+R8", "TPM2u+R9", "TPM2u+R10", "TPM3", "TPM3+I", "TPM3+G", "TPM3+I+G", "TPM3+R2", "TPM3+R3", "TPM3+R4", "TPM3+R5", "TPM3+R6", "TPM3+R7", "TPM3+R8", "TPM3+R9", "TPM3+R10", "TPM3u", "TPM3u+I", "TPM3u+G", "TPM3u+I+G", "TPM3u+R2", "TPM3u+R3", "TPM3u+R4", "TPM3u+R5", "TPM3u+R6", "TPM3u+R7", "TPM3u+R8", "TPM3u+R9", "TPM3u+R10", "TIMe", "TIMe+I", "TIMe+G", "TIMe+I+G", "TIMe+R2", "TIMe+R3", "TIMe+R4", "TIMe+R5", "TIMe+R6", "TIMe+R7", "TIMe+R8", "TIMe+R9", "TIMe+R10", "TIM", "TIM+I", "TIM+G", "TIM+I+G", "TIM+R2", "TIM+R3", "TIM+R4", "TIM+R5", "TIM+R6", "TIM+R7", "TIM+R8", "TIM+R9", "TIM+R10", "TIM2e", "TIM2e+I", "TIM2e+G", "TIM2e+I+G", "TIM2e+R2", "TIM2e+R3", "TIM2e+R4", "TIM2e+R5", "TIM2e+R6", "TIM2e+R7", "TIM2e+R8", "TIM2e+R9", "TIM2e+R10", "TIM2", "TIM2+I", "TIM2+G", "TIM2+I+G", "TIM2+R2", "TIM2+R3", "TIM2+R4", "TIM2+R5", "TIM2+R6", "TIM2+R7", "TIM2+R8", "TIM2+R9", "TIM2+R10", "TIM3e", "TIM3e+I", "TIM3e+G", "TIM3e+I+G", "TIM3e+R2", "TIM3e+R3", "TIM3e+R4", "TIM3e+R5", "TIM3e+R6", "TIM3e+R7", "TIM3e+R8", "TIM3e+R9", "TIM3e+R10", "TIM3", "TIM3+I", "TIM3+G", "TIM3+I+G", "TIM3+R2", "TIM3+R3", "TIM3+R4", "TIM3+R5", "TIM3+R6", "TIM3+R7", "TIM3+R8", "TIM3+R9", "TIM3+R10", "TVMe", "TVMe+I", "TVMe+G", "TVMe+I+G", "TVMe+R2", "TVMe+R3", "TVMe+R4", "TVMe+R5", "TVMe+R6", "TVMe+R7", "TVMe+R8", "TVMe+R9", "TVMe+R10", "TVM", "TVM+I", "TVM+G", "TVM+I+G", "TVM+R2", "TVM+R3", "TVM+R4", "TVM+R5", "TVM+R6", "TVM+R7", "TVM+R8", "TVM+R9", "TVM+R10", "SYM", "SYM+I", "SYM+G", "SYM+I+G", "SYM+R2", "SYM+R3", "SYM+R4", "SYM+R5", "SYM+R6", "SYM+R7", "SYM+R8", "SYM+R9", "SYM+R10", "GTR", "GTR+I", "GTR+G", "GTR+I+G", "GTR+R2", "GTR+R3", "GTR+R4", "GTR+R5", "GTR+R6", "GTR+R7", "GTR+R8", "GTR+R9", "GTR+R10", "MFP", "TEST"]}, "fields": []}, "type": "parameter", "description": "Model of Nucleotide Substitution.If not provided, IQ-TREE will determine the best fit substitution model automatically. ", "default": "MFP", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "bootstrap_replicates", "repr": "Range(1000, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1000, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of bootstrap searches to perform. Minimum of 1000 recomended. ", "default": 1000, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_init_pars_trees", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of initial parsimony trees. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_top_init_trees", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of top initial trees. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_best_retain_trees", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of best trees retained during search. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "stop_iter", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of unsuccessful iterations to stop. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "perturb_nni_strength", "repr": "Range(0.01, 99)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.01, 99], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Perturbation strength for randomized NNI. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "spr_radius", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Radius for parsimony SPR search. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_max_ufboot_iter", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Maximum number of iterations. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_ufboot_steps", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of iterations for UFBoot stopping rule. If not set, program defaults will be used.See IQ-TREE manual for details.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_cor_ufboot", "repr": "Range(0.51, 0.99)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.51, 0.99], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Minimum correlation coefficient. If not set, program defaults will be used.See IQ-TREE manual for details.", "default": null, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "ep_break_ufboot", "repr": "Range(0.01, 0.99)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.01, 0.99], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Epsilon value to break tie. If not set, program defaults will be used. See IQ-TREE manual for details.", "default": null, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "allnni", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Perform more thorough NNI search.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "alrt", "repr": "Range(1000, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1000, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Single branch test method. Number of bootstrap replicates to perform an SH-like approximate likelihood ratio test (SH-aLRT). Minimum of 1000 replicates is recomended. Set to '0' for parametric aLRT test. Can be used with other 'single branch test methods'. Values reported in the order of: alrt, lbp, abayes, ufboot.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "abayes", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Single branch test method. Performs an approximate Bayes test. Can be used with other 'single branch test methods' and ultrafast bootstrap. Values reported in the order of: alrt, lbp, abayes, ufboot.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "lbp", "repr": "Range(1000, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1000, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Single branch test method. Number of bootstrap replicates to perform a fast local bootstrap probability method. Minimum of 1000 replicates is recomended. Can be used with other 'single branch test methods'. Values reported in the order of: alrt, lbp, abayes, ufboot.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "bnni", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Optimize UFBoot trees by NNI on bootstrap alignment. This option reduces the risk of overestimating branch supports with UFBoot due to severe model violations.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "safe", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Safe likelihood kernel to avoid numerical underflow.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "tree", "repr": "Phylogeny[Unrooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Unrooted", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting phylogenetic tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "filter_table": {"id": "filter_table", "name": "Remove features from table if they're not present in tree.", "description": "Remove features from a feature table if their identifiers are not tip identifiers in tree.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table that features should be filtered from.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Phylogeny[Rooted | Unrooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Unrooted", "predicate": null, "fields": []}]}]}, "type": "input", "description": "Tree where tip identifiers are the feature identifiers that should be retained in the table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "filtered_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "align_to_tree_mafft_fasttree": {"id": "align_to_tree_mafft_fasttree", "name": "Build a phylogenetic tree using fasttree and mafft alignment", "description": "This pipeline will start by creating a sequence alignment using MAFFT, after which any alignment columns that are phylogenetically uninformative or ambiguously aligned will be removed (masked). The resulting masked alignment will be used to infer a phylogenetic tree and then subsequently rooted at its midpoint. Output files from each step of the pipeline will be saved. This includes both the unmasked and masked MAFFT alignment from q2-alignment methods, and both the rooted and unrooted phylogenies from q2-phylogeny methods.", "signature": [{"name": "sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The sequences to be used for creating a fasttree based rooted phylogenetic tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_threads", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of threads. (Use 0 to automatically use all available cores) This value is used when aligning the sequences and creating the tree with fasttree.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "mask_max_gap_frequency", "repr": "Range(0, 1, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The maximum relative frequency of gap characters in a column for the column to be retained. This relative frequency must be a number between 0.0 and 1.0 (inclusive), where 0.0 retains only those columns without gap characters, and 1.0 retains all columns  regardless of gap character frequency. This value is used when masking the aligned sequences.", "default": 1.0, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "mask_min_conservation", "repr": "Range(0, 1, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The minimum relative frequency of at least one non-gap character in a column for that column to be retained. This relative frequency must be a number between 0.0 and 1.0 (inclusive). For example, if a value of  0.4 is provided, a column will only be retained  if it contains at least one character that is present in at least 40% of the sequences. This value is used when masking the aligned sequences.", "default": 0.4, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "alignment", "repr": "FeatureData[AlignedSequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlignedSequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The aligned sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "masked_alignment", "repr": "FeatureData[AlignedSequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlignedSequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The masked alignment.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Phylogeny[Unrooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Unrooted", "predicate": null, "fields": []}]}, "type": "output", "description": "The unrooted phylogenetic tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "rooted_tree", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "output", "description": "The rooted phylogenetic tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "metadata": {"id": "metadata", "name": "metadata", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-metadata", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin provides functionality for working with and visualizing Metadata.", "short_description": "Plugin for working with Metadata.", "actions": {"distance_matrix": {"id": "distance_matrix", "name": "Create a distance matrix from a numeric Metadata column", "description": "Create a distance matrix from a numeric metadata column. The Euclidean distance is computed between each pair of samples or features in the column.\n\nTip: the distance matrix produced by this method can be used as input to the Mantel test available in `q2-diversity`.", "signature": [{"name": "metadata", "repr": "MetadataColumn[Numeric]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Numeric", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Numeric metadata column to compute pairwise Euclidean distances from", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "output", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "tabulate": {"id": "tabulate", "name": "Interactively explore Metadata in an HTML table", "description": "Generate a tabular view of Metadata. The output visualization supports interactive filtering, sorting, and exporting to common file formats.", "signature": [{"name": "input", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The metadata to tabulate.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "page_size", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The maximum number of Metadata records to display per page", "default": 100, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "longitudinal": {"id": "longitudinal", "name": "longitudinal", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-longitudinal", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin supports methods for analysis of time series data, involving either paired sample comparisons or longitudinal study designs.", "short_description": "Plugin for paired sample and time series analyses.", "actions": {"nmit": {"id": "nmit", "name": "Nonparametric microbial interdependence test", "description": "Perform nonparametric microbial interdependence test to determine longitudinal sample similarity as a function of temporal microbial composition. For more details and citation, please see doi.org/10.1002/gepi.22065", "signature": [{"name": "table", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table to use for microbial interdependence test.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata file containing individual_id_column.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "individual_id_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing IDs for individual subjects.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "corr_method", "repr": "Choices('kendall', 'pearson', 'spearman')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["kendall", "pearson", "spearman"]}, "fields": []}, "type": "parameter", "description": "The temporal correlation test to be applied.", "default": "kendall", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "dist_method", "repr": "Choices('fro', 'nuc')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["fro", "nuc"]}, "fields": []}, "type": "parameter", "description": "Temporal distance method, see numpy.linalg.norm for details.", "default": "fro", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "output", "description": "The resulting distance matrix.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "first_differences": {"id": "first_differences", "name": "Compute first differences or difference from baseline between sequential states", "description": "Calculates first differences in \"metric\" between sequential states for samples collected from individual subjects sampled repeatedly at two or more states. First differences can be performed on a metadata column (including artifacts that can be input as metadata) or a feature in a feature table. Outputs a data series of first differences for each individual subject at each sequential pair of states, labeled by the SampleID of the second state (e.g., paired differences between time 0 and time 1 would be labeled by the SampleIDs at time 1). This file can be used as input to linear mixed effects models or other longitudinal or diversity methods to compare changes in first differences across time or among groups of subjects. Also supports differences from baseline (or other static comparison state) by setting the \"baseline\" parameter.", "signature": [{"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata file containing individual_id_column.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "state_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing state (time) variable information.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "individual_id_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing IDs for individual subjects.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metric", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Numerical metadata or artifact column to test.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "replicate_handling", "repr": "Choices('error', 'random', 'drop')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "random", "drop"]}, "fields": []}, "type": "parameter", "description": "Choose how replicate samples are handled. If replicates are detected, \"error\" causes method to fail; \"drop\" will discard all replicated samples; \"random\" chooses one representative at random from among replicates.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "baseline", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "A value listed in the state_column metadata column against which all other states should be compared. Toggles calculation of static differences instead of first differences (which are calculated if no value is given for baseline). If a \"baseline\" value is provided, sample differences at each state are compared against the baseline state, instead of the previous state. Must be a value listed in the state_column.", "default": null, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "table", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table to optionally use for computing first differences.", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "first_differences", "repr": "SampleData[FirstDifferences]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "FirstDifferences", "predicate": null, "fields": []}]}, "type": "output", "description": "Series of first differences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "first_distances": {"id": "first_distances", "name": "Compute first distances or distance from baseline between sequential states", "description": "Calculates first distances between sequential states for samples collected from individual subjects sampled repeatedly at two or more states. This method is similar to the \"first differences\" method, except that it requires a distance matrix as input and calculates first differences as distances between successive states. Outputs a data series of first distances for each individual subject at each sequential pair of states, labeled by the SampleID of the second state (e.g., paired distances between time 0 and time 1 would be labeled by the SampleIDs at time 1). This file can be used as input to linear mixed effects models or other longitudinal or diversity methods to compare changes in first distances across time or among groups of subjects. Also supports distance from baseline (or other static comparison state) by setting the \"baseline\" parameter.", "signature": [{"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "input", "description": "Matrix of distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata file containing individual_id_column.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "state_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing state (time) variable information.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "individual_id_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing IDs for individual subjects.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "baseline", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "A value listed in the state_column metadata column against which all other states should be compared. Toggles calculation of static distances instead of first distances (which are calculated if no value is given for baseline). If a \"baseline\" value is provided, sample distances at each state are compared against the baseline state, instead of the previous state. Must be a value listed in the state_column.", "default": null, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "replicate_handling", "repr": "Choices('error', 'random', 'drop')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "random", "drop"]}, "fields": []}, "type": "parameter", "description": "Choose how replicate samples are handled. If replicates are detected, \"error\" causes method to fail; \"drop\" will discard all replicated samples; \"random\" chooses one representative at random from among replicates.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "first_distances", "repr": "SampleData[FirstDifferences]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "FirstDifferences", "predicate": null, "fields": []}]}, "type": "output", "description": "Series of first distances.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "pairwise_differences": {"id": "pairwise_differences", "name": "Paired difference testing and boxplots", "description": "Performs paired difference testing between samples from each subject. Sample pairs may represent a typical intervention study, e.g., samples collected pre- and post-treatment; paired samples from two different timepoints (e.g., in a longitudinal study design), or identical samples receiving different two different treatments. This action tests whether the change in a numeric metadata value \"metric\" differs from zero and differs between groups (e.g., groups of subjects receiving different treatments), and produces boxplots of paired difference distributions for each group. A feature table artifact is required input, though whether \"metric\" is derived from the feature table or metadata is optional.", "signature": [{"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata file containing individual_id_column.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "metric", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Numerical metadata or artifact column to test.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "state_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing state (e.g., Time) across which samples are paired.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "state_1", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Baseline state column value.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "state_2", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "State column value to pair with baseline.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "individual_id_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing subject IDs to use for pairing samples. WARNING: if replicates exist for an individual ID at either state_1 or state_2, that subject will be dropped and reported in standard output by default. Set replicate_handling=\"random\" to instead randomly select one member.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "group_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column on which to separate groups for comparison", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "parametric", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Perform parametric (ANOVA and t-tests) or non-parametric (Kruskal-Wallis, Wilcoxon, and Mann-Whitney U tests) statistical tests.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "palette", "repr": "Choices('Set1', 'Set2', 'Set3', 'Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', 'tab10', 'tab20', 'tab20b', 'tab20c', 'viridis', 'plasma', 'inferno', 'magma', 'terrain', 'rainbow', 'cividis')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["Set1", "Set2", "Set3", "Pastel1", "Pastel2", "Paired", "Accent", "Dark2", "tab10", "tab20", "tab20b", "tab20c", "viridis", "plasma", "inferno", "magma", "terrain", "rainbow", "cividis"]}, "fields": []}, "type": "parameter", "description": "Color palette to use for generating boxplots.", "default": "Set1", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "replicate_handling", "repr": "Choices('error', 'random', 'drop')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "random", "drop"]}, "fields": []}, "type": "parameter", "description": "Choose how replicate samples are handled. If replicates are detected, \"error\" causes method to fail; \"drop\" will discard all replicated samples; \"random\" chooses one representative at random from among replicates.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "table", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table to optionally use for paired comparisons.", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "pairwise_distances": {"id": "pairwise_distances", "name": "Paired pairwise distance testing and boxplots", "description": "Performs pairwise distance testing between sample pairs from each subject. Sample pairs may represent a typical intervention study, e.g., samples collected pre- and post-treatment; paired samples from two different timepoints (e.g., in a longitudinal study design), or identical samples receiving different two different treatments. This action tests whether the pairwise distance between each subject pair differs between groups (e.g., groups of subjects receiving different treatments) and produces boxplots of paired distance distributions for each group.", "signature": [{"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "input", "description": "Matrix of distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata file containing individual_id_column.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "group_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column on which to separate groups for comparison", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "state_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing state (e.g., Time) across which samples are paired.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "state_1", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Baseline state column value.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "state_2", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "State column value to pair with baseline.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "individual_id_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing subject IDs to use for pairing samples. WARNING: if replicates exist for an individual ID at either state_1 or state_2, that subject will be dropped and reported in standard output by default. Set replicate_handling=\"random\" to instead randomly select one member.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "parametric", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Perform parametric (ANOVA and t-tests) or non-parametric (Kruskal-Wallis, Wilcoxon, and Mann-Whitney U tests) statistical tests.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "palette", "repr": "Choices('Set1', 'Set2', 'Set3', 'Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', 'tab10', 'tab20', 'tab20b', 'tab20c', 'viridis', 'plasma', 'inferno', 'magma', 'terrain', 'rainbow', 'cividis')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["Set1", "Set2", "Set3", "Pastel1", "Pastel2", "Paired", "Accent", "Dark2", "tab10", "tab20", "tab20b", "tab20c", "viridis", "plasma", "inferno", "magma", "terrain", "rainbow", "cividis"]}, "fields": []}, "type": "parameter", "description": "Color palette to use for generating boxplots.", "default": "Set1", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "replicate_handling", "repr": "Choices('error', 'random', 'drop')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "random", "drop"]}, "fields": []}, "type": "parameter", "description": "Choose how replicate samples are handled. If replicates are detected, \"error\" causes method to fail; \"drop\" will discard all replicated samples; \"random\" chooses one representative at random from among replicates.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "linear_mixed_effects": {"id": "linear_mixed_effects", "name": "Linear mixed effects modeling", "description": "Linear mixed effects models evaluate the contribution of exogenous covariates \"group_columns\" and \"random_effects\" to a single dependent variable, \"metric\". Perform LME and plot line plots of each group column. A feature table artifact is required input, though whether \"metric\" is derived from the feature table or metadata is optional.", "signature": [{"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata file containing individual_id_column.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "state_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing state (time) variable information.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "individual_id_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing IDs for individual subjects.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metric", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Dependent variable column name. Must be a column name located in the metadata or feature table files.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "group_columns", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Comma-separated list (without spaces) of metadata columns to use as independent covariates used to determine mean structure of \"metric\".", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "random_effects", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Comma-separated list (without spaces) of metadata columns to use as independent covariates used to determine the variance and covariance structure (random effects) of \"metric\". To add a random slope, the same value passed to \"state_column\" should be passed here. A random intercept for each individual is set by default and does not need to be passed here.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "table", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing metric.", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "palette", "repr": "Choices('Set1', 'Set2', 'Set3', 'Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', 'tab10', 'tab20', 'tab20b', 'tab20c', 'viridis', 'plasma', 'inferno', 'magma', 'terrain', 'rainbow', 'cividis')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["Set1", "Set2", "Set3", "Pastel1", "Pastel2", "Paired", "Accent", "Dark2", "tab10", "tab20", "tab20b", "tab20c", "viridis", "plasma", "inferno", "magma", "terrain", "rainbow", "cividis"]}, "fields": []}, "type": "parameter", "description": "Color palette to use for generating boxplots.", "default": "Set1", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "lowess", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Estimate locally weighted scatterplot smoothing. Note that this will eliminate confidence interval plotting.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "ci", "repr": "Range(0, 100)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 100], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Size of the confidence interval for the regression estimate.", "default": 95, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "formula", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "R-style formula to use for model specification. A formula must be used if the \"metric\" parameter is None. Note that the metric and group columns specified in the formula will override metric and group columns that are passed separately as parameters to this method. Formulae will be in the format \"a ~ b + c\", where \"a\" is the metric (dependent variable) and \"b\" and \"c\" are independent covariates. Use \"+\" to add a variable; \"+ a:b\" to add an interaction between variables a and b; \"*\" to include a variable and all interactions; and \"-\" to subtract a particular term (e.g., an interaction term). See https://patsy.readthedocs.io/en/latest/formulas.html for full documentation of valid formula operators. Always enclose formulae in quotes to avoid unpleasant surprises.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "anova": {"id": "anova", "name": "ANOVA test", "description": "Perform an ANOVA test on any factors present in a metadata file and/or metadata-transformable artifacts. This is followed by pairwise t-tests to examine pairwise differences between categorical sample groups.", "signature": [{"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata containing formula terms.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "formula", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "R-style formula specifying the model. All terms must be present in the sample metadata or metadata-transformable artifacts and can be continuous or categorical metadata columns. Formulae will be in the format \"a ~ b + c\", where \"a\" is the metric (dependent variable) and \"b\" and \"c\" are independent covariates. Use \"+\" to add a variable; \"+ a:b\" to add an interaction between variables a and b; \"*\" to include a variable and all interactions; and \"-\" to subtract a particular term (e.g., an interaction term). See https://patsy.readthedocs.io/en/latest/formulas.html for full documentation of valid formula operators. Always enclose formulae in quotes to avoid unpleasant surprises.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sstype", "repr": "Choices('I', 'II', 'III')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["I", "II", "III"]}, "fields": []}, "type": "parameter", "description": "Type of sum of squares calculation to perform (I, II, or III).", "default": "II", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "volatility": {"id": "volatility", "name": "Generate interactive volatility plot", "description": "Generate an interactive control chart depicting the longitudinal volatility of sample metadata and/or feature frequencies across time (as set using the \"state_column\" parameter). Any numeric metadata column (and metadata-transformable artifacts, e.g., alpha diversity results) can be plotted on the y-axis, and are selectable using the \"metric_column\" selector. Metric values are averaged to compare across any categorical metadata column using the \"group_column\" selector. Longitudinal volatility for individual subjects sampled over time is co-plotted as \"spaghetti\" plots if the \"individual_id_column\" parameter is used. state_column will typically be a measure of time, but any numeric metadata column can be used.", "signature": [{"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata file containing individual_id_column.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "state_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing state (time) variable information.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "individual_id_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing IDs for individual subjects.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "default_group_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "The default metadata column on which to separate groups for comparison (all categorical metadata columns will be available in the visualization).", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "default_metric", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Numeric metadata or artifact column to test by default (all numeric metadata columns will be available in the visualization).", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "table", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing metrics.", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "yscale", "repr": "Choices('linear', 'pow', 'sqrt', 'log')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["linear", "pow", "sqrt", "log"]}, "fields": []}, "type": "parameter", "description": "y-axis scaling strategy to apply.", "default": "linear", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "plot_feature_volatility": {"id": "plot_feature_volatility", "name": "Plot longitudinal feature volatility and importances", "description": "Plots an interactive control chart of feature abundances (y-axis) in each sample across time (or state; x-axis). Feature importance scores and descriptive statistics for each feature are plotted in interactive bar charts below the control chart, facilitating exploration of longitudinal feature data. This visualization is intended for use with the feature-volatility pipeline; use that pipeline to access this visualization.", "signature": [{"name": "table", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing features found in importances.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "importances", "repr": "FeatureData[Importance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Importance", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature importance scores.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata file containing individual_id_column.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "state_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing state (time) variable information.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "individual_id_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing IDs for individual subjects.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "default_group_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "The default metadata column on which to separate groups for comparison (all categorical metadata columns will be available in the visualization).", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "yscale", "repr": "Choices('linear', 'pow', 'sqrt', 'log')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["linear", "pow", "sqrt", "log"]}, "fields": []}, "type": "parameter", "description": "y-axis scaling strategy to apply.", "default": "linear", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "importance_threshold", "repr": "Float % Range(0, None, inclusive_start=False) | Str % Choices('q1', 'q2', 'q3')", "ast": {"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [false, false]}, "fields": []}, {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["q1", "q2", "q3"]}, "fields": []}]}, "type": "parameter", "description": "Filter feature table to exclude any features with an importance score less than this threshold. Set to \"q1\", \"q2\", or \"q3\" to select the first, second, or third quartile of values. Set to \"None\" to disable this filter.", "default": null, "metavar": "VALUE", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feature_count", "repr": "Int % Range(1, None) | Str % Choices('all')", "ast": {"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["all"]}, "fields": []}]}, "type": "parameter", "description": "Filter feature table to include top N most important features. Set to \"all\" to include all features.", "default": 100, "metavar": "VALUE", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "feature_volatility": {"id": "feature_volatility", "name": "Feature volatility analysis", "description": "Identify features that are predictive of a numeric metadata column, state_column (e.g., time), and plot their relative frequencies across states using interactive feature volatility plots. A supervised learning regressor is used to identify important features and assess their ability to predict sample states. state_column will typically be a measure of time, but any numeric metadata column can be used.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata file containing individual_id_column.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "state_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata containing collection time (state) values for each sample. Must contain exclusively numeric values.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "individual_id_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata column containing IDs for individual subjects.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "cv", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of k-fold cross-validations to perform.", "default": 5, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "random_state", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Seed used by random number generator.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to run in parallel.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_estimators", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of trees to grow for estimation. More trees will improve predictive accuracy up to a threshold level, but will also increase time and memory requirements. This parameter only affects ensemble estimators, such as Random Forest, AdaBoost, ExtraTrees, and GradientBoosting.", "default": 100, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "estimator", "repr": "Choices('RandomForestRegressor', 'ExtraTreesRegressor', 'GradientBoostingRegressor', 'AdaBoostRegressor', 'ElasticNet', 'Ridge', 'Lasso', 'KNeighborsRegressor', 'LinearSVR', 'SVR')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["RandomForestRegressor", "ExtraTreesRegressor", "GradientBoostingRegressor", "AdaBoostRegressor", "ElasticNet", "Ridge", "Lasso", "KNeighborsRegressor", "LinearSVR", "SVR"]}, "fields": []}, "type": "parameter", "description": "Estimator method to use for sample prediction.", "default": "RandomForestRegressor", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "parameter_tuning", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically tune hyperparameters using random grid search.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "importance_threshold", "repr": "Float % Range(0, None, inclusive_start=False) | Str % Choices('q1', 'q2', 'q3')", "ast": {"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [false, false]}, "fields": []}, {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["q1", "q2", "q3"]}, "fields": []}]}, "type": "parameter", "description": "Filter feature table to exclude any features with an importance score less than this threshold. Set to \"q1\", \"q2\", or \"q3\" to select the first, second, or third quartile of values. Set to \"None\" to disable this filter.", "default": null, "metavar": "VALUE", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feature_count", "repr": "Int % Range(1, None) | Str % Choices('all')", "ast": {"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["all"]}, "fields": []}]}, "type": "parameter", "description": "Filter feature table to include top N most important features. Set to \"all\" to include all features.", "default": 100, "metavar": "VALUE", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "filtered_table", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "output", "description": "Feature table containing only important features.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feature_importance", "repr": "FeatureData[Importance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Importance", "predicate": null, "fields": []}]}, "type": "output", "description": "Importance of each input feature to model accuracy.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "volatility_plot", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Interactive volatility plot visualization.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "accuracy_results", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Accuracy results visualization.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_estimator", "repr": "SampleEstimator[Regressor]", "ast": {"type": "expression", "builtin": false, "name": "SampleEstimator", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Regressor", "predicate": null, "fields": []}]}, "type": "output", "description": "Trained sample regressor.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "maturity_index": {"id": "maturity_index", "name": "Microbial maturity index prediction.", "description": "Calculates a \"microbial maturity\" index from a regression model trained on feature data to predict a given continuous metadata column, e.g., to predict age as a function of microbiota composition. The model is trained on a subset of control group samples, then predicts the column value for all samples. This visualization computes maturity index z-scores to compare relative \"maturity\" between each group, as described in doi:10.1038/nature13421. This method can be used to predict between-group differences in relative trajectory across any type of continuous metadata gradient, e.g., intestinal microbiome development by age, microbial succession during wine fermentation, or microbial community differences along environmental gradients, as a function of two or more different \"treatment\" groups.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table containing all features that should be used for target prediction.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "state_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Numeric metadata column containing sampling time (state) data to use as prediction target.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "group_by", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Categorical metadata column to use for plotting and significance testing between main treatment groups.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "control", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Value of group_by to use as control group. The regression model will be trained using only control group data, and the maturity scores of other groups consequently will be assessed relative to this group.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "individual_id_column", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Optional metadata column containing IDs for individual subjects. Adds individual subject (spaghetti) vectors to volatility charts if a column name is provided.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "estimator", "repr": "Choices('RandomForestRegressor', 'ExtraTreesRegressor', 'GradientBoostingRegressor', 'AdaBoostRegressor', 'ElasticNet', 'Ridge', 'Lasso', 'KNeighborsRegressor', 'LinearSVR', 'SVR')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["RandomForestRegressor", "ExtraTreesRegressor", "GradientBoostingRegressor", "AdaBoostRegressor", "ElasticNet", "Ridge", "Lasso", "KNeighborsRegressor", "LinearSVR", "SVR"]}, "fields": []}, "type": "parameter", "description": "Regression model to use for prediction.", "default": "RandomForestRegressor", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_estimators", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of trees to grow for estimation. More trees will improve predictive accuracy up to a threshold level, but will also increase time and memory requirements. This parameter only affects ensemble estimators, such as Random Forest, AdaBoost, ExtraTrees, and GradientBoosting.", "default": 100, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "test_size", "repr": "Range(0.0, 1.0, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "Fraction of input samples to exclude from training set and use for classifier testing.", "default": 0.5, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "step", "repr": "Range(0.0, 1.0, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "If optimize_feature_selection is True, step is the percentage of features to remove at each iteration.", "default": 0.05, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "cv", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of k-fold cross-validations to perform.", "default": 5, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "random_state", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Seed used by random number generator.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to run in parallel.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "parameter_tuning", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically tune hyperparameters using random grid search.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "optimize_feature_selection", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Automatically optimize input feature selection using recursive feature elimination.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "stratify", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Evenly stratify training and test data among metadata categories. If True, all values in column must match at least two samples.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "missing_samples", "repr": "Choices('error', 'ignore')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error", "ignore"]}, "fields": []}, "type": "parameter", "description": "How to handle missing samples in metadata. \"error\" will fail if missing samples are detected. \"ignore\" will cause the feature table and metadata to be filtered, so that only samples found in both files are retained.", "default": "error", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feature_count", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Filter feature table to include top N most important features. Set to zero to include all features.", "default": 50, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_estimator", "repr": "SampleEstimator[Regressor]", "ast": {"type": "expression", "builtin": false, "name": "SampleEstimator", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Regressor", "predicate": null, "fields": []}]}, "type": "output", "description": "Trained sample estimator.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feature_importance", "repr": "FeatureData[Importance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Importance", "predicate": null, "fields": []}]}, "type": "output", "description": "Importance of each input feature to model accuracy.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "predictions", "repr": "SampleData[RegressorPredictions]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RegressorPredictions", "predicate": null, "fields": []}]}, "type": "output", "description": "Predicted target values for each input sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "model_summary", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Summarized parameter and (if enabled) feature selection information for the trained estimator.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "accuracy_results", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Accuracy results visualization.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "maz_scores", "repr": "SampleData[RegressorPredictions]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RegressorPredictions", "predicate": null, "fields": []}]}, "type": "output", "description": "Microbiota-for-age z-score predictions.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "clustermap", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Heatmap of important feature abundance at each time point in each group.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "volatility_plots", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Interactive volatility plots of MAZ and maturity scores, target (column) predictions, and the sample metadata.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "gneiss": {"id": "gneiss", "name": "gneiss", "version": "2019.10.0", "website": "https://biocore.github.io/gneiss/", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This is a QIIME 2 plugin supporting statistical models on feature tables and metadata using balances.", "short_description": "Plugin for building compositional models.", "actions": {"ilr_hierarchical": {"id": "ilr_hierarchical", "name": "Isometric Log-ratio Transform applied to a hierarchical clustering", "description": "Calculate balances given a hierarchy.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency | Composition]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Composition", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The feature table containing the samples in which the ilr transform will be performed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Hierarchy", "ast": {"type": "expression", "builtin": false, "name": "Hierarchy", "predicate": null, "fields": []}, "type": "input", "description": "A hierarchy of feature identifiers that defines the partitions of features.  Each tip in the hierarchycorresponds to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree.  This assumes that all of the internal nodes in the tree have labels.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "pseudocount", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The value to add to zero counts in the feature table.", "default": 0.5, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "balances", "repr": "FeatureTable[Balance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Balance", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting balances from the ilr transform.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "ilr_phylogenetic": {"id": "ilr_phylogenetic", "name": "Isometric Log-ratio Transform applied to a phylogenetic tree", "description": "Calculate balances given a rooted phylogeny.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency | Composition]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Composition", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The feature table containing the samples in which the ilr transform will be performed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "input", "description": "A rooted phylogeny of feature identifiers that defines the partitions of features.  Each tip in the hierarchycorresponds to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree.  This assumes that all of the internal nodes in the tree have labels. This tree may contain polytomic nodes (i.e., nodes with more than two children), in which case they will be bifurcated.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "pseudocount", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The value to add to zero counts in the feature table.", "default": 0.5, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "balances", "repr": "FeatureTable[Balance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Balance", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting balances from the ilr transform.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "hierarchy", "repr": "Hierarchy", "ast": {"type": "expression", "builtin": false, "name": "Hierarchy", "predicate": null, "fields": []}, "type": "output", "description": "Hierarchy from bifurcated phylogeny", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "correlation_clustering": {"id": "correlation_clustering", "name": "Hierarchical clustering using feature correlation.", "description": "Build a bifurcating tree that represents a hierarchical clustering of features.  The hiearchical clustering uses Ward hierarchical clustering based on the degree of proportionality between features.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table containing the samples in which the columns will be clustered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "pseudocount", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The value to add to zero counts in the feature table.", "default": 0.5, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "clustering", "repr": "Hierarchy", "ast": {"type": "expression", "builtin": false, "name": "Hierarchy", "predicate": null, "fields": []}, "type": "output", "description": "A hierarchy of feature identifiers where each tip corresponds to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "gradient_clustering": {"id": "gradient_clustering", "name": "Hierarchical clustering using gradient information.", "description": "Build a bifurcating tree that represents a hierarchical clustering of features.  The hiearchical clustering uses Ward hierarchical clustering based on the mean difference of gradients that each feature is observed in. This method is primarily used to sort the table to reveal the underlying block-like structures.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency | RelativeFrequency | Composition]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Composition", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The feature table containing the samples in which the columns will be clustered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "gradient", "repr": "MetadataColumn[Numeric]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Numeric", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Contains gradient values to sort the features and samples.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "ignore_missing_samples", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "weighted", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Specifies if abundance or presence/absence information should be used to perform the clustering.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "clustering", "repr": "Hierarchy", "ast": {"type": "expression", "builtin": false, "name": "Hierarchy", "predicate": null, "fields": []}, "type": "output", "description": "A hierarchy of feature identifiers where each tip corresponds to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "assign_ids": {"id": "assign_ids", "name": "Assigns ids on internal nodes in the tree, and makes sure that they are consistent with the table columns.", "description": "Assigns UUIDs to uniquely identify internal nodes in the tree.  Also corrects for polytomies to create strictly bifurcating trees and aligns the table columns with the tree tip names", "signature": [{"name": "input_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The input table of counts.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "input_tree", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "input", "description": "The input tree with potential missing ids.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "output_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "A table with features matching the tree tips.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "output_tree", "repr": "Hierarchy", "ast": {"type": "expression", "builtin": false, "name": "Hierarchy", "predicate": null, "fields": []}, "type": "output", "description": "A tree with uniquely identifying ids.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "ols_regression": {"id": "ols_regression", "name": "Simplicial Ordinary Least Squares Regression", "description": "Perform linear regression on balances. This will tell youhow much variability is explained by metadata categories in your formula.", "signature": [{"name": "table", "repr": "FeatureTable[Balance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Balance", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table containing the samples in which simplicial regression will be performed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Hierarchy", "ast": {"type": "expression", "builtin": false, "name": "Hierarchy", "predicate": null, "fields": []}, "type": "input", "description": "A hierarchy of feature identifiers where each tipcorresponds to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata information that contains the covariates of interest.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "formula", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Formula specifying the statistical model. In other words, a list of the metadata categories that will be used in the regression model, typically separated by \"+\". For more information see https://patsy.readthedocs.io/en/latest/API-reference.html", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": true}, "lme_regression": {"id": "lme_regression", "name": "Simplicial Linear mixed effects regression", "description": "Build and run linear mixed effects model on balances. Use LME over OLS when you have repeated measurements such as (timeseries).", "signature": [{"name": "table", "repr": "FeatureTable[Balance]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Balance", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table containing the samples in which simplicial regression with mixed effect will be performed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Hierarchy", "ast": {"type": "expression", "builtin": false, "name": "Hierarchy", "predicate": null, "fields": []}, "type": "input", "description": "A hierarchy of feature identifiers where each tip corresponds to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Metadata information that contains the covariates of interest.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "formula", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Statistical formula specifying the statistical model. In other words, a list of the metadata categories that will be used in the linear mixed effect model, typically separated by \"+\". For more information see https://patsy.readthedocs.io/en/latest/API-reference.html", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "groups", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": true}, "balance_taxonomy": {"id": "balance_taxonomy", "name": "Balance Summary", "description": "Visualize the distribution of a single balance and summarize its numerator and denominator components.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "A table of abundances.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Hierarchy", "ast": {"type": "expression", "builtin": false, "name": "Hierarchy", "predicate": null, "fields": []}, "type": "input", "description": "The tree used to calculate the balances.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "taxonomy", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "description": "Taxonomy information for the OTUs.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "balance_name", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Name of the balance to summarize.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "pseudocount", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The pseudocount to add to avoid division by zero.", "default": 0.5, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "taxa_level", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Level of taxonomy to summarize.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_features", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of features to plot in the proportion plot.", "default": 10, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "threshold", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "A threshold to designate discrete categories for a numerical metadata column. This will split the numerical column values into two categories, values below the threshold, and values above the threshold. If not specified, this threshold will default to the mean.", "default": null, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Categorical | Numeric]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}, {"type": "expression", "builtin": true, "name": "Numeric", "predicate": null, "fields": []}]}]}, "type": "parameter", "description": "Metadata column for plotting the balance (optional).", "default": null, "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": true}, "dendrogram_heatmap": {"id": "dendrogram_heatmap", "name": "Dendrogram heatmap.", "description": "Visualize the feature table as a heatmap, with samples sorted along a specified categorical metadata column and features clustered together specified by the tree.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table that will be plotted as a heatmap. This table is assumed to have strictly positive values.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Hierarchy", "ast": {"type": "expression", "builtin": false, "name": "Hierarchy", "predicate": null, "fields": []}, "type": "input", "description": "A hierarchy of feature identifiers where each tipcorresponds to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Categorical metadata column to group the samples.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "pseudocount", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The pseudocount to add to avoid division by zero.", "default": 0.5, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "ndim", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of dimensions to highlight.", "default": 10, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "method", "repr": "Choices('clr', 'log')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["clr", "log"]}, "fields": []}, "type": "parameter", "description": "Specifies how the data should be normalized for display.Options include 'log' or 'clr' (default='clr').", "default": "clr", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "color_map", "repr": "Choices('viridis', 'inferno', 'plasma', 'magma', 'Blues', 'BuGn', 'BuPu', 'GnBu', 'Greens', 'Greys', 'Oranges', 'OrRd', 'PuBu', 'PuBuGn', 'PuRd', 'Purples', 'RdPu', 'Reds', 'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd', 'afmhot', 'autumn', 'bone', 'cool', 'copper', 'gist_heat', 'gray', 'hot', 'pink', 'spring', 'summer', 'winter', 'BrBG', 'bwr', 'coolwarm', 'PiYG', 'PRGn', 'PuOr', 'RdBu', 'RdGy', 'RdYlBu', 'RdYlGn', 'Spectral', 'seismic', 'Accent', 'Dark2', 'Paired', 'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3', 'Vega10', 'Vega20', 'Vega20b', 'Vega20c', 'gist_earth', 'terrain', 'ocean', 'gist_stern', 'brg', 'CMRmap', 'cubehelix', 'gnuplot', 'gnuplot2', 'gist_ncar', 'nipy_spectral', 'jet', 'rainbow', 'gist_rainbow', 'hsv', 'flag', 'prism')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["viridis", "inferno", "plasma", "magma", "Blues", "BuGn", "BuPu", "GnBu", "Greens", "Greys", "Oranges", "OrRd", "PuBu", "PuBuGn", "PuRd", "Purples", "RdPu", "Reds", "YlGn", "YlGnBu", "YlOrBr", "YlOrRd", "afmhot", "autumn", "bone", "cool", "copper", "gist_heat", "gray", "hot", "pink", "spring", "summer", "winter", "BrBG", "bwr", "coolwarm", "PiYG", "PRGn", "PuOr", "RdBu", "RdGy", "RdYlBu", "RdYlGn", "Spectral", "seismic", "Accent", "Dark2", "Paired", "Pastel1", "Pastel2", "Set1", "Set2", "Set3", "Vega10", "Vega20", "Vega20b", "Vega20c", "gist_earth", "terrain", "ocean", "gist_stern", "brg", "CMRmap", "cubehelix", "gnuplot", "gnuplot2", "gist_ncar", "nipy_spectral", "jet", "rainbow", "gist_rainbow", "hsv", "flag", "prism"]}, "fields": []}, "type": "parameter", "description": "Specifies the color map for plotting the heatmap. See https://matplotlib.org/examples/color/colormaps_reference.html for more details.", "default": "viridis", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": true}}}, "fragment-insertion": {"id": "fragment_insertion", "name": "fragment-insertion", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-fragment-insertion", "user_support_text": "https://github.com/qiime2/q2-fragment-insertion/issues", "description": "No description available. See plugin website: https://github.com/qiime2/q2-fragment-insertion", "short_description": "Plugin for extending phylogenies.", "actions": {"sepp": {"id": "sepp", "name": "Insert fragment sequences using SEPP into reference phylogenies.", "description": "Perform fragment insertion of sequences using the SEPP algorithm.", "signature": [{"name": "representative_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The sequences to insert into the reference tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_database", "repr": "SeppReferenceDatabase", "ast": {"type": "expression", "builtin": false, "name": "SeppReferenceDatabase", "predicate": null, "fields": []}, "type": "input", "description": "The reference database to insert the representative sequences into.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "alignment_subset_size", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Each placement subset is further broken into subsets of at most these many sequences and a separate HMM is trained on each subset.", "default": 1000, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "placement_subset_size", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The tree is divided into subsets such that each subset includes at most these many subsets. The placement step places the fragment on only one subset, determined based on alignment scores. Further reading: https://github.com/smirarab/sepp/blob/master/tutorial/sepp-tutorial.md#sample-datasets-default-parameters.", "default": 5000, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "threads", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of threads to use.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "debug", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Collect additional run information to STDOUT for debugging. Temporary directories will not be removed if run fails.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "tree", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "output", "description": "The tree with inserted feature data.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "placements", "repr": "Placements", "ast": {"type": "expression", "builtin": false, "name": "Placements", "predicate": null, "fields": []}, "type": "output", "description": "Information about the feature placements within the reference tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "classify_otus_experimental": {"id": "classify_otus_experimental", "name": "Experimental: Obtain taxonomic lineages, by finding closest OTU in reference phylogeny.", "description": "Experimental: Use the resulting tree from 'sepp' and find closest OTU-ID for every inserted fragment. Then, look up the reference lineage string in the reference taxonomy.", "signature": [{"name": "representative_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The sequences used for a 'sepp' run to produce the 'tree'.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "input", "description": "The tree resulting from inserting fragments into a reference phylogeny, i.e. the output of function 'sepp'", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_taxonomy", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "description": "Reference taxonomic table that maps every OTU-ID into a taxonomic lineage string.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classification", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "output", "description": "Taxonomic lineages for inserted fragments.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "filter_features": {"id": "filter_features", "name": "Filter fragments in tree from table.", "description": "Filters fragments not inserted into a phylogenetic tree from a feature-table. Some fragments computed by e.g. Deblur or DADA2 are too remote to get inserted by SEPP into a reference phylogeny. To be able to use the feature-table for downstream analyses like computing Faith's PD or UniFrac, the feature-table must be cleared of fragments that are not part of the phylogenetic tree, because their path length can otherwise not be determined. Typically, the number of rejected fragments is low (<= 10), but it might be worth to inspect the ratio of reads assigned to those rejected fragments.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "A feature-table which needs to filtered down to those fragments that are contained in the tree, e.g. result of a Deblur or DADA2 run.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "tree", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "input", "description": "The tree resulting from inserting fragments into a reference phylogeny, i.e. the output of function 'sepp'", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "filtered_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The input table minus those fragments that were not part of the tree. This feature-table can be used for downstream analyses like phylogenetic alpha- or beta- diversity computation.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "removed_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "Those fragments that got removed from the input table, because they were not part of the tree. This table is mainly used for quality control, e.g. to inspect the ratio of removed reads per sample from the input table. You can ignore this table for downstream analyses.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "feature-table": {"id": "feature_table", "name": "feature-table", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-feature-table", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This is a QIIME 2 plugin supporting operations on sample by feature tables, such as filtering, merging, and transforming tables.", "short_description": "Plugin for working with sample by feature tables.", "actions": {"rarefy": {"id": "rarefy", "name": "Rarefy table", "description": "Subsample frequencies from all samples so that the sum of frequencies in each sample is equal to sampling-depth.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table to be rarefied.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sampling_depth", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The total frequency that each sample should be rarefied to. Samples where the sum of frequencies is less than the sampling depth will be not be included in the resulting table unless subsampling is performed with replacement.", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "with_replacement", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Rarefy with replacement by sampling from the multinomial distribution instead of rarefying without replacement.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "rarefied_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting rarefied feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "subsample": {"id": "subsample", "name": "Subsample table", "description": "Randomly pick samples or features, without replacement, from the table.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table to be sampled.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "subsampling_depth", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The total number of samples or features to be randomly sampled. Samples or features that are reduced to a zero sum will not be included in the resulting table.", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "axis", "repr": "Choices('sample', 'feature')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["sample", "feature"]}, "fields": []}, "type": "parameter", "description": "The axis to sample over. If \"sample\" then samples will be randomly selected to be retained. If \"feature\" then a random set of features will be selected to be retained.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sampled_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting subsampled feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "presence_absence": {"id": "presence_absence", "name": "Convert to presence/absence", "description": "Convert frequencies to binary values indicating presence or absence of a feature in a sample.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency | RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The feature table to be converted into presence/absence abundances.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "presence_absence_table", "repr": "FeatureTable[PresenceAbsence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting presence/absence feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "relative_frequency": {"id": "relative_frequency", "name": "Convert to relative frequencies", "description": "Convert frequencies to relative frequencies by dividing each frequency in a sample by the sum of frequencies in that sample.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table to be converted into relative frequencies.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "relative_frequency_table", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting relative frequency feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "transpose": {"id": "transpose", "name": "Transpose a feature table.", "description": "Transpose the rows and columns (typically samples and features) of a feature table.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table to be transposed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "transposed_feature_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting transposed feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "group": {"id": "group", "name": "Group samples or features by a metadata column", "description": "Group samples or features in a feature table using metadata to define the mapping of IDs to a group.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The table to group samples or features on.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "axis", "repr": "Choices('sample', 'feature')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["sample", "feature"]}, "fields": []}, "type": "parameter", "description": "Along which axis to group. Each ID in the given axis must exist in `metadata`.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "A column defining the groups. Each unique value will become a new ID for the table on the given `axis`.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "mode", "repr": "Choices('sum', 'median-ceiling', 'mean-ceiling')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["sum", "median-ceiling", "mean-ceiling"]}, "fields": []}, "type": "parameter", "description": "How to combine samples or features within a group. `sum` will sum the frequencies across all samples or features within a group; `mean-ceiling` will take the ceiling of the mean of these frequencies; `median-ceiling` will take the ceiling of the median of these frequencies.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "grouped_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "A table that has been grouped along the given `axis`. IDs on that axis are replaced by values in the `metadata` column.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "merge": {"id": "merge", "name": "Combine multiple tables", "description": "Combines feature tables using the `overlap_method` provided.", "signature": [{"name": "tables", "repr": "List[FeatureTable[Frequency]]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The collection of feature tables to be merged.", "metavar": "ARTIFACTS...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "overlap_method", "repr": "Choices('error_on_overlapping_sample', 'error_on_overlapping_feature', 'sum')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["error_on_overlapping_sample", "error_on_overlapping_feature", "sum"]}, "fields": []}, "type": "parameter", "description": "Method for handling overlapping ids.", "default": "error_on_overlapping_sample", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "merged_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting merged feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "merge_seqs": {"id": "merge_seqs", "name": "Combine collections of feature sequences", "description": "Combines feature data objects which may or may not contain data for the same features. If different feature data is present for the same feature id in the inputs, the data from the first will be propagated to the result.", "signature": [{"name": "data", "repr": "List[FeatureData[Sequence]]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The collection of feature sequences to be merged.", "metavar": "ARTIFACTS...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "merged_data", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting collection of feature sequences containing all feature sequences provided.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "merge_taxa": {"id": "merge_taxa", "name": "Combine collections of feature taxonomies", "description": "Combines a pair of feature data objects which may or may not contain data for the same features. If different feature data is present for the same feature id in the inputs, the data from the first will be propagated to the result.", "signature": [{"name": "data", "repr": "List[FeatureData[Taxonomy]]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The collection of feature taxonomies to be merged.", "metavar": "ARTIFACTS...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "merged_data", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting collection of feature taxonomies containing all feature taxonomies provided.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "filter_samples": {"id": "filter_samples", "name": "Filter samples from table", "description": "Filter samples from table based on frequency and/or metadata. Any features with a frequency of zero after sample filtering will also be removed. See the filtering tutorial on https://docs.qiime2.org for additional details.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency\u00b9 | RelativeFrequency\u00b2 | PresenceAbsence\u00b3 | Composition\u2074]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "variable", "index": 1, "group": 140664435185256, "outputs": 1, "mapping": [[{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "Composition", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Composition", "predicate": null, "fields": []}]]}]}, "type": "input", "description": "The feature table from which samples should be filtered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_frequency", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The minimum total frequency that a sample must have to be retained.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_frequency", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The maximum total frequency that a sample can have to be retained. If no value is provided this will default to infinity (i.e., no maximum frequency filter will be applied).", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_features", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The minimum number of features that a sample must have to be retained.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_features", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The maximum number of features that a sample can have to be retained. If no value is provided this will default to infinity (i.e., no maximum feature filter will be applied).", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata used with `where` parameter when selecting samples to retain, or with `exclude_ids` when selecting samples to discard.", "default": null, "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "where", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "SQLite WHERE clause specifying sample metadata criteria that must be met to be included in the filtered feature table. If not provided, all samples in `metadata` that are also in the feature table will be retained.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "exclude_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If true, the samples selected by `metadata` or `where` parameters will be excluded from the filtered table instead of being retained.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "filtered_table", "repr": "FeatureTable[Frequency\u00b9 | RelativeFrequency\u00b2 | PresenceAbsence\u00b3 | Composition\u2074]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "variable", "index": 1, "group": 140664435185256, "outputs": 1, "mapping": [[{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "Composition", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "Composition", "predicate": null, "fields": []}]]}]}, "type": "output", "description": "The resulting feature table filtered by sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "filter_features": {"id": "filter_features", "name": "Filter features from table", "description": "Filter features from table based on frequency and/or metadata. Any samples with a frequency of zero after feature filtering will also be removed. See the filtering tutorial on https://docs.qiime2.org for additional details.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table from which features should be filtered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_frequency", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The minimum total frequency that a feature must have to be retained.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_frequency", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The maximum total frequency that a feature can have to be retained. If no value is provided this will default to infinity (i.e., no maximum frequency filter will be applied).", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_samples", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The minimum number of samples that a feature must be observed in to be retained.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_samples", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The maximum number of samples that a feature can be observed in to be retained. If no value is provided this will default to infinity (i.e., no maximum sample filter will be applied).", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Feature metadata used with `where` parameter when selecting features to retain, or with `exclude_ids` when selecting features to discard.", "default": null, "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "where", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "SQLite WHERE clause specifying feature metadata criteria that must be met to be included in the filtered feature table. If not provided, all features in `metadata` that are also in the feature table will be retained.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "exclude_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If true, the features selected by `metadata` or `where` parameters will be excluded from the filtered table instead of being retained.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "filtered_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature table filtered by feature.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "filter_seqs": {"id": "filter_seqs", "name": "Filter features from sequences", "description": "Filter features from sequences based on a feature table or metadata. See the filtering tutorial on https://docs.qiime2.org for additional details. This method can filter based on ids in a table or a metadata file, but not both (i.e., the table and metadata options are mutually exclusive).", "signature": [{"name": "data", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The sequences from which features should be filtered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Table containing feature ids used for id-based filtering.", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Feature metadata used for id-based filtering, with `where` parameter when selecting features to retain, or with `exclude_ids` when selecting features to discard.", "default": null, "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "where", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "SQLite WHERE clause specifying feature metadata criteria that must be met to be included in the filtered feature table. If not provided, all features in `metadata` that are also in the sequences will be retained.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "exclude_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If true, the features selected by the `metadata` (with or without the `where` parameter) or `table` parameter will be excluded from the filtered sequences instead of being retained.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "filtered_data", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting filtered sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "summarize": {"id": "summarize", "name": "Summarize table", "description": "Generate visual and tabular summaries of a feature table.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency | RelativeFrequency | PresenceAbsence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PresenceAbsence", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The feature table to be summarized.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata.", "default": null, "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "tabulate_seqs": {"id": "tabulate_seqs", "name": "View sequence associated with each feature", "description": "Generate tabular view of feature identifier to sequence mapping, including links to BLAST each sequence against the NCBI nt database.", "signature": [{"name": "data", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature sequences to be tabulated.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "core_features": {"id": "core_features", "name": "Identify core features in table", "description": "Identify \"core\" features, which are features observed in a user-defined fraction of the samples. Since the core features are a function of the fraction of samples that the feature must be observed in to be considered core, this is computed over a range of fractions defined by the `min_fraction`, `max_fraction`, and `steps` parameters.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table to use in core features calculations.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_fraction", "repr": "Range(0.0, 1.0, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "The minimum fraction of samples that a feature must be observed in for that feature to be considered a core feature.", "default": 0.5, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_fraction", "repr": "Range(0.0, 1.0, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The maximum fraction of samples that a feature must be observed in for that feature to be considered a core feature.", "default": 1.0, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "steps", "repr": "Range(2, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [2, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of steps to take between `min_fraction` and `max_fraction` for core features calculations. This parameter has no effect if `min_fraction` and `max_fraction` are the same value.", "default": 11, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "heatmap": {"id": "heatmap", "name": "Generate a heatmap representation of a feature table", "description": "Generate a heatmap representation of a feature table with optional clustering on both the sample and feature axes.\n\nTip: To generate a heatmap containing taxonomic annotations, use `qiime taxa collapse` to collapse the feature table at the desired taxonomic level.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table to visualize.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Annotate the sample IDs with these sample metadata values. When metadata is present and `cluster`='feature', samples will be sorted by the metadata values.", "default": null, "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "feature_metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Annotate the feature IDs with these feature metadata values. When metadata is present and `cluster`='sample', features will be sorted by the metadata values.", "default": null, "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "normalize", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Normalize the feature table by adding a psuedocount of 1 and then taking the log10 of the table.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "title", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Optional custom plot title.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metric", "repr": "Choices('kulsinski', 'cosine', 'dice', 'cityblock', 'matching', 'sokalsneath', 'canberra', 'hamming', 'jaccard', 'mahalanobis', 'correlation', 'seuclidean', 'sokalmichener', 'chebyshev', 'sqeuclidean', 'rogerstanimoto', 'euclidean', 'minkowski', 'yule', 'russellrao', 'braycurtis')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["kulsinski", "cosine", "dice", "cityblock", "matching", "sokalsneath", "canberra", "hamming", "jaccard", "mahalanobis", "correlation", "seuclidean", "sokalmichener", "chebyshev", "sqeuclidean", "rogerstanimoto", "euclidean", "minkowski", "yule", "russellrao", "braycurtis"]}, "fields": []}, "type": "parameter", "description": "Metrics exposed by seaborn (see http://seaborn.pydata.org/generated/seaborn.clustermap.html#seaborn.clustermap for more detail).", "default": "euclidean", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "method", "repr": "Choices('single', 'centroid', 'weighted', 'ward', 'complete', 'average', 'median')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["single", "centroid", "weighted", "ward", "complete", "average", "median"]}, "fields": []}, "type": "parameter", "description": "Clustering methods exposed by seaborn (see http://seaborn.pydata.org/generated/seaborn.clustermap.html#seaborn.clustermap for more detail).", "default": "average", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "cluster", "repr": "Choices('samples', 'features', 'both', 'none')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["samples", "features", "both", "none"]}, "fields": []}, "type": "parameter", "description": "Specify which axes to cluster.", "default": "both", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "color_scheme", "repr": "Choices('bwr_r', 'vlag_r', 'GnBu', 'PuBu', 'brg_r', 'gist_yarg_r', 'winter', 'OrRd_r', 'summer', 'CMRmap_r', 'RdGy', 'Purples', 'seismic_r', 'gist_gray_r', 'PuRd', 'flag_r', 'BuPu', 'spectral', 'PuRd_r', 'Oranges', 'coolwarm_r', 'RdYlBu', 'YlOrBr', 'CMRmap', 'Oranges_r', 'Set1_r', 'Set2', 'Vega10_r', 'binary', 'plasma', 'RdYlGn_r', 'terrain', 'gist_ncar', 'Vega10', 'pink_r', 'Wistia_r', 'PiYG_r', 'binary_r', 'cubehelix', 'YlGn_r', 'mako_r', 'Wistia', 'RdBu', 'prism', 'YlGn', 'icefire', 'PRGn', 'copper_r', 'YlGnBu_r', 'summer_r', 'RdPu_r', 'gist_yarg', 'Vega20b', 'prism_r', 'Greens', 'Spectral', 'YlOrRd', 'magma', 'bwr', 'ocean', 'gray', 'jet_r', 'seismic', 'gist_earth_r', 'pink', 'Set3', 'inferno_r', 'PRGn_r', 'gist_rainbow_r', 'BrBG_r', 'gist_heat_r', 'cividis', 'afmhot_r', 'bone', 'tab20_r', 'gnuplot2', 'hot_r', 'BrBG', 'copper', 'Paired', 'YlOrBr_r', 'Accent_r', 'Set3_r', 'cubehelix_r', 'Reds', 'PiYG', 'Vega20c', 'RdPu', 'YlGnBu', 'gist_rainbow', 'Set1', 'inferno', 'tab10_r', 'coolwarm', 'bone_r', 'Pastel2', 'icefire_r', 'rocket_r', 'BuPu_r', 'tab20b_r', 'gist_heat', 'Vega20', 'Reds_r', 'flag', 'viridis', 'RdBu_r', 'rainbow', 'magma_r', 'gnuplot_r', 'Blues_r', 'BuGn_r', 'cividis_r', 'ocean_r', 'Pastel1', 'spectral_r', 'gist_stern_r', 'hsv_r', 'mako', 'gist_ncar_r', 'jet', 'Greys_r', 'rocket', 'GnBu_r', 'gist_earth', 'hsv', 'Accent', 'Dark2_r', 'Greens_r', 'brg', 'nipy_spectral_r', 'PuOr_r', 'tab20c', 'tab10', 'winter_r', 'RdYlBu_r', 'Set2_r', 'gnuplot', 'PuBuGn_r', 'plasma_r', 'spring_r', 'RdGy_r', 'YlOrRd_r', 'tab20', 'tab20b', 'tab20c_r', 'autumn', 'Greys', 'Pastel1_r', 'gnuplot2_r', 'PuBuGn', 'Blues', 'Dark2', 'cool_r', 'gist_stern', 'rainbow_r', 'autumn_r', 'gist_gray', 'BuGn', 'Spectral_r', 'OrRd', 'Vega20c_r', 'nipy_spectral', 'Pastel2_r', 'Vega20_r', 'afmhot', 'Vega20b_r', 'Purples_r', 'cool', 'gray_r', 'vlag', 'spring', 'RdYlGn', 'hot', 'Paired_r', 'terrain_r', 'PuOr', 'viridis_r', 'PuBu_r')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["bwr_r", "vlag_r", "GnBu", "PuBu", "brg_r", "gist_yarg_r", "winter", "OrRd_r", "summer", "CMRmap_r", "RdGy", "Purples", "seismic_r", "gist_gray_r", "PuRd", "flag_r", "BuPu", "spectral", "PuRd_r", "Oranges", "coolwarm_r", "RdYlBu", "YlOrBr", "CMRmap", "Oranges_r", "Set1_r", "Set2", "Vega10_r", "binary", "plasma", "RdYlGn_r", "terrain", "gist_ncar", "Vega10", "pink_r", "Wistia_r", "PiYG_r", "binary_r", "cubehelix", "YlGn_r", "mako_r", "Wistia", "RdBu", "prism", "YlGn", "icefire", "PRGn", "copper_r", "YlGnBu_r", "summer_r", "RdPu_r", "gist_yarg", "Vega20b", "prism_r", "Greens", "Spectral", "YlOrRd", "magma", "bwr", "ocean", "gray", "jet_r", "seismic", "gist_earth_r", "pink", "Set3", "inferno_r", "PRGn_r", "gist_rainbow_r", "BrBG_r", "gist_heat_r", "cividis", "afmhot_r", "bone", "tab20_r", "gnuplot2", "hot_r", "BrBG", "copper", "Paired", "YlOrBr_r", "Accent_r", "Set3_r", "cubehelix_r", "Reds", "PiYG", "Vega20c", "RdPu", "YlGnBu", "gist_rainbow", "Set1", "inferno", "tab10_r", "coolwarm", "bone_r", "Pastel2", "icefire_r", "rocket_r", "BuPu_r", "tab20b_r", "gist_heat", "Vega20", "Reds_r", "flag", "viridis", "RdBu_r", "rainbow", "magma_r", "gnuplot_r", "Blues_r", "BuGn_r", "cividis_r", "ocean_r", "Pastel1", "spectral_r", "gist_stern_r", "hsv_r", "mako", "gist_ncar_r", "jet", "Greys_r", "rocket", "GnBu_r", "gist_earth", "hsv", "Accent", "Dark2_r", "Greens_r", "brg", "nipy_spectral_r", "PuOr_r", "tab20c", "tab10", "winter_r", "RdYlBu_r", "Set2_r", "gnuplot", "PuBuGn_r", "plasma_r", "spring_r", "RdGy_r", "YlOrRd_r", "tab20", "tab20b", "tab20c_r", "autumn", "Greys", "Pastel1_r", "gnuplot2_r", "PuBuGn", "Blues", "Dark2", "cool_r", "gist_stern", "rainbow_r", "autumn_r", "gist_gray", "BuGn", "Spectral_r", "OrRd", "Vega20c_r", "nipy_spectral", "Pastel2_r", "Vega20_r", "afmhot", "Vega20b_r", "Purples_r", "cool", "gray_r", "vlag", "spring", "RdYlGn", "hot", "Paired_r", "terrain_r", "PuOr", "viridis_r", "PuBu_r"]}, "fields": []}, "type": "parameter", "description": "The matplotlib colorscheme to generate the heatmap with.", "default": "rocket", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "feature-classifier": {"id": "feature_classifier", "name": "feature-classifier", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-feature-classifier", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin supports taxonomic classification of features using a variety of methods, including Naive Bayes, vsearch, and BLAST+.", "short_description": "Plugin for taxonomic classification.", "actions": {"fit_classifier_sklearn": {"id": "fit_classifier_sklearn", "name": "Train an almost arbitrary scikit-learn classifier", "description": "Train a scikit-learn classifier to classify reads.", "signature": [{"name": "reference_reads", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_taxonomy", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classifier_specification", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "class_weight", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classifier", "repr": "TaxonomicClassifier", "ast": {"type": "expression", "builtin": false, "name": "TaxonomicClassifier", "predicate": null, "fields": []}, "type": "output", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "classify_sklearn": {"id": "classify_sklearn", "name": "Pre-fitted sklearn-based taxonomy classifier", "description": "Classify reads by taxon using a fitted classifier.", "signature": [{"name": "reads", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature data to be classified.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classifier", "repr": "TaxonomicClassifier", "ast": {"type": "expression", "builtin": false, "name": "TaxonomicClassifier", "predicate": null, "fields": []}, "type": "input", "description": "The taxonomic classifier for classifying the reads.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reads_per_batch", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of reads to process in each batch. If \"auto\", this parameter is autoscaled to min( number of query sequences / n_jobs, 20000).", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The maximum number of concurrently worker processes. If -1 all CPUs are used. If 1 is given, no parallel computing code is used at all, which is useful for debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for n_jobs = -2, all CPUs but one are used.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "pre_dispatch", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "\"all\" or expression, as in \"3*n_jobs\". The number of batches (of tasks) to be pre-dispatched.", "default": "2*n_jobs", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "confidence", "repr": "Float % Range(0, 1, inclusive_end=True) | Str % Choices('disable')", "ast": {"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [true, true]}, "fields": []}, {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["disable"]}, "fields": []}]}, "type": "parameter", "description": "Confidence threshold for limiting taxonomic depth. Set to \"disable\" to disable confidence calculation, or 0 to calculate confidence but not apply it to limit the taxonomic depth of the assignments.", "default": 0.7, "metavar": "VALUE", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "read_orientation", "repr": "Choices('same', 'reverse-complement', 'auto')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["same", "reverse-complement", "auto"]}, "fields": []}, "type": "parameter", "description": "Direction of reads with respect to reference sequences. same will cause reads to be classified unchanged; reverse-complement will cause reads to be reversed and complemented prior to classification. \"auto\" will autodetect orientation based on the confidence estimates for the first 100 reads.", "default": "auto", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classification", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "output", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "fit_classifier_naive_bayes": {"id": "fit_classifier_naive_bayes", "name": "Train the naive_bayes classifier", "description": "Create a scikit-learn naive_bayes classifier for reads", "signature": [{"name": "reference_reads", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_taxonomy", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "class_weight", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classify__alpha", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "default": 0.001, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classify__chunk_size", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "default": 20000, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classify__class_prior", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "null", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classify__fit_prior", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "feat_ext__alternate_sign", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "feat_ext__analyzer", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "char_wb", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feat_ext__binary", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "feat_ext__decode_error", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "strict", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feat_ext__encoding", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "utf-8", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feat_ext__input", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "content", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feat_ext__lowercase", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "feat_ext__n_features", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "default": 8192, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feat_ext__ngram_range", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "[7, 7]", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feat_ext__norm", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "l2", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feat_ext__preprocessor", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "null", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feat_ext__stop_words", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "null", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feat_ext__strip_accents", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "null", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feat_ext__token_pattern", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "(?u)\\b\\w\\w+\\b", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "feat_ext__tokenizer", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "null", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "verbose", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "classifier", "repr": "TaxonomicClassifier", "ast": {"type": "expression", "builtin": false, "name": "TaxonomicClassifier", "predicate": null, "fields": []}, "type": "output", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "extract_reads": {"id": "extract_reads", "name": "Extract reads from reference", "description": "Extract sequencing-like reads from a reference database.", "signature": [{"name": "sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "f_primer", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "forward primer sequence", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "r_primer", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "reverse primer sequence", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trunc_len", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "read is cut to trunc_len if trunc_len is positive. Applied before trim_left.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trim_left", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "trim_left nucleotides are removed from the 5' end if trim_left is positive. Applied after trunc_len.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "identity", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "minimum combined primer match identity threshold.", "default": 0.8, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_length", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Minimum amplicon length. Shorter amplicons are discarded. Applied after trimming and truncation, so be aware that trimming may impact sequence retention. Set to zero to disable min length filtering.", "default": 50, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_length", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Maximum amplicon length. Longer amplicons are discarded. Applied before trimming and truncation, so plan accordingly. Set to zero (default) to disable max length filtering.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of seperate processes to run.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "batch_size", "repr": "Int % Range(1, None) | Str % Choices('auto')", "ast": {"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["auto"]}, "fields": []}]}, "type": "parameter", "description": "Number of sequences to process in a batch. The `auto` option is calculated from the number of sequences and number of jobs specified.", "default": "auto", "metavar": "VALUE", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reads", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "classify_consensus_blast": {"id": "classify_consensus_blast", "name": "BLAST+ consensus taxonomy classifier", "description": "Assign taxonomy to query sequences using BLAST+. Performs BLAST+ local alignment between query and reference_reads, then assigns consensus taxonomy to each query sequence from among maxaccepts hits, min_consensus of which share that taxonomic assignment. Note that maxaccepts selects the first N hits with > perc_identity similarity to query, not the top N matches. For top N hits, use classify-consensus-vsearch.", "signature": [{"name": "query", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Sequences to classify taxonomically.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_reads", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "reference sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_taxonomy", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "description": "reference taxonomy labels.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "maxaccepts", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Maximum number of hits to keep for each query. Must be in range [1, infinity]. BLAST will choose the first N hits in the reference database that exceed perc_identity similarity to query.", "default": 10, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "perc_identity", "repr": "Range(0.0, 1.0, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "Reject match if percent identity to query is lower. Must be in range [0.0, 1.0].", "default": 0.8, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "query_cov", "repr": "Range(0.0, 1.0, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "Reject match if query alignment coverage per high-scoring pair is lower. Note: this uses blastn's qcov_hsp_perc parameter, and may not behave identically to the query_cov parameter used by classify-consensus-vsearch. Must be in range [0.0, 1.0].", "default": 0.8, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "strand", "repr": "Choices('both', 'plus', 'minus')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["both", "plus", "minus"]}, "fields": []}, "type": "parameter", "description": "Align against reference sequences in forward (\"plus\"), reverse (\"minus\"), or both directions (\"both\").", "default": "both", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "evalue", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "BLAST expectation value (E) threshold for saving hits.", "default": 0.001, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_consensus", "repr": "Range(0.5, 1.0, inclusive_start=False, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.5, 1.0], "inclusive": [false, true]}, "fields": []}, "type": "parameter", "description": "Minimum fraction of assignments must match top hit to be accepted as consensus assignment. Must be in range (0.5, 1.0].", "default": 0.51, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "unassignable_label", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "Unassigned", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classification", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "output", "description": "Taxonomy classifications of query sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "classify_consensus_vsearch": {"id": "classify_consensus_vsearch", "name": "VSEARCH-based consensus taxonomy classifier", "description": "Assign taxonomy to query sequences using VSEARCH. Performs VSEARCH global alignment between query and reference_reads, then assigns consensus taxonomy to each query sequence from among maxaccepts top hits, min_consensus of which share that taxonomic assignment. Unlike classify-consensus-blast, this method searches the entire reference database before choosing the top N hits, not the first N hits.", "signature": [{"name": "query", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Sequences to classify taxonomically.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_reads", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "reference sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_taxonomy", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "description": "reference taxonomy labels.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "maxaccepts", "repr": "Int % Range(1, None) | Str % Choices('all')", "ast": {"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["all"]}, "fields": []}]}, "type": "parameter", "description": "Maximum number of hits to keep for each query. Set to \"all\" to keep all hits > perc_identity similarity.", "default": 10, "metavar": "VALUE", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "perc_identity", "repr": "Range(0.0, 1.0, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "Reject match if percent identity to query is lower.", "default": 0.8, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "query_cov", "repr": "Range(0.0, 1.0, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "Reject match if query alignment coverage per high-scoring pair is lower.", "default": 0.8, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "strand", "repr": "Choices('both', 'plus')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["both", "plus"]}, "fields": []}, "type": "parameter", "description": "Align against reference sequences in forward (\"plus\") or both directions (\"both\").", "default": "both", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_consensus", "repr": "Range(0.5, 1.0, inclusive_start=False, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.5, 1.0], "inclusive": [false, true]}, "fields": []}, "type": "parameter", "description": "Minimum fraction of assignments must match top hit to be accepted as consensus assignment.", "default": 0.51, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "unassignable_label", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "default": "Unassigned", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "search_exact", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Search for exact full-length matches to the query sequences. Only 100% exact matches are reported and this command is much faster than the default. If True, the perc_identity and query_cov settings are ignored. Note: query and reference reads must be trimmed to the exact same DNA locus (e.g., primer site) because only exact matches will be reported.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "top_hits_only", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Only the top hits between the query and reference sequence sets are reported. For each query, the top hit is the one presenting the highest percentage of identity. Multiple equally scored top hits will be used for consensus taxonomic assignment if maxaccepts is greater than 1.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "threads", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of threads to use for job parallelization.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classification", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting taxonomy classifications.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "classify_hybrid_vsearch_sklearn": {"id": "classify_hybrid_vsearch_sklearn", "name": "ALPHA Hybrid classifier: VSEARCH exact match + sklearn classifier", "description": "NOTE: THIS PIPELINE IS AN ALPHA RELEASE. Please report bugs to https://forum.qiime2.org!\nAssign taxonomy to query sequences using hybrid classifier. First performs rough positive filter to remove artifact and low-coverage sequences (use \"prefilter\" parameter to toggle this step on or off). Second, performs VSEARCH exact match between query and reference_reads to find exact matches, followed by least common ancestor consensus taxonomy assignment from among maxaccepts top hits, min_consensus of which share that taxonomic assignment. Query sequences without an exact match are then classified with a pre-trained sklearn taxonomy classifier to predict the most likely taxonomic lineage.", "signature": [{"name": "query", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Sequences to classify taxonomically.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_reads", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "reference sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_taxonomy", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "input", "description": "reference taxonomy labels.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classifier", "repr": "TaxonomicClassifier", "ast": {"type": "expression", "builtin": false, "name": "TaxonomicClassifier", "predicate": null, "fields": []}, "type": "input", "description": "Pre-trained sklearn taxonomic classifier for classifying the reads.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "maxaccepts", "repr": "Int % Range(1, None) | Str % Choices('all')", "ast": {"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["all"]}, "fields": []}]}, "type": "parameter", "description": "Maximum number of hits to keep for each query. Set to \"all\" to keep all hits > perc_identity similarity.", "default": 10, "metavar": "VALUE", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "perc_identity", "repr": "Range(0.0, 1.0, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "Percent sequence similarity to use for PREFILTER. Reject match if percent identity to query is lower. Set to a lower value to perform a rough pre-filter. This parameter is ignored if `prefilter` is disabled.", "default": 0.5, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "query_cov", "repr": "Range(0.0, 1.0, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.0, 1.0], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "Query coverage threshold to use for PREFILTER. Reject match if query alignment coverage per high-scoring pair is lower. Set to a lower value to perform a rough pre-filter. This parameter is ignored if `prefilter` is disabled.", "default": 0.8, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "strand", "repr": "Choices('both', 'plus')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["both", "plus"]}, "fields": []}, "type": "parameter", "description": "Align against reference sequences in forward (\"plus\") or both directions (\"both\").", "default": "both", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_consensus", "repr": "Range(0.5, 1.0, inclusive_start=False, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0.5, 1.0], "inclusive": [false, true]}, "fields": []}, "type": "parameter", "description": "Minimum fraction of assignments must match top hit to be accepted as consensus assignment.", "default": 0.51, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reads_per_batch", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of reads to process in each batch for sklearn classification. If \"auto\", this parameter is autoscaled to min(number of query sequences / threads, 20000).", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "confidence", "repr": "Float % Range(0, 1, inclusive_end=True) | Str % Choices('disable')", "ast": {"type": "union", "members": [{"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [true, true]}, "fields": []}, {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["disable"]}, "fields": []}]}, "type": "parameter", "description": "Confidence threshold for limiting taxonomic depth. Set to \"disable\" to disable confidence calculation, or 0 to calculate confidence but not apply it to limit the taxonomic depth of the assignments.", "default": 0.7, "metavar": "VALUE", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "read_orientation", "repr": "Choices('same', 'reverse-complement', 'auto')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["same", "reverse-complement", "auto"]}, "fields": []}, "type": "parameter", "description": "Direction of reads with respect to reference sequences in pre-trained sklearn classifier. same will cause reads to be classified unchanged; reverse-complement will cause reads to be reversed and complemented prior to classification. \"auto\" will autodetect orientation based on the confidence estimates for the first 100 reads.", "default": "auto", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "threads", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of threads to use for job parallelization.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "prefilter", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Toggle positive filter of query sequences on or off.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "sample_size", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Randomly extract the given number of sequences from the reference database to use for prefiltering. This parameter is ignored if `prefilter` is disabled.", "default": 1000, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "randseed", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Use integer as a seed for the pseudo-random generator used during prefiltering. A given seed always produces the same output, which is useful for replicability. Set to 0 to use a pseudo-random seed. This parameter is ignored if `prefilter` is disabled.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "classification", "repr": "FeatureData[Taxonomy]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Taxonomy", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting taxonomy classifications.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "emperor": {"id": "emperor", "name": "emperor", "version": "2019.10.0", "website": "http://emperor.microbio.me", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin wraps Emperor and supports interactive visualization of ordination plots.", "short_description": "Plugin for ordination plotting with Emperor.", "actions": {"plot": {"id": "plot", "name": "Visualize and Interact with Principal Coordinates Analysis Plots", "description": "Generates an interactive ordination plot where the user can visually integrate sample metadata.", "signature": [{"name": "pcoa", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "input", "description": "The principal coordinates matrix to be plotted.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "custom_axes", "repr": "List[Str]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Numeric sample metadata columns that should be included as axes in the Emperor plot.", "default": null, "metavar": "TEXT...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "ignore_missing_samples", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "This will suppress the error raised when the coordinates matrix contains samples that are not present in the metadata. Samples without metadata are included by setting all metadata values to: \"This sample has no metadata\". This flag is only applied if at least one sample is present in both the coordinates matrix and the metadata.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "procrustes_plot": {"id": "procrustes_plot", "name": "Visualize and Interact with a procrustes plot", "description": "Plot two procrustes-fitted matrices", "signature": [{"name": "reference_pcoa", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "input", "description": "The reference ordination matrix to be plotted.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "other_pcoa", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "input", "description": "The \"other\" ordination matrix to be plotted (the one that was fitted to the reference).", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "custom_axes", "repr": "List[Str]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Numeric sample metadata columns that should be included as axes in the Emperor plot.", "default": null, "metavar": "TEXT...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "ignore_missing_samples", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "This will suppress the error raised when the coordinates matrix contains samples that are not present in the metadata. Samples without metadata are included by setting all metadata values to: \"This sample has no metadata\". This flag is only applied if at least one sample is present in both the coordinates matrix and the metadata.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "biplot": {"id": "biplot", "name": "Visualize and Interact with Principal Coordinates Analysis Biplot", "description": "Generates an interactive ordination biplot where the user can visually integrate sample and feature metadata. Vectors representing the n most important features are then plotted in the emperor visualization (5 largest, by default).", "signature": [{"name": "biplot", "repr": "PCoAResults % Properties('biplot')", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": {"type": "predicate", "name": "Properties", "include": ["biplot"], "exclude": []}, "fields": []}, "type": "input", "description": "The principal coordinates matrix to be plotted.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "feature_metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The feature metadata (useful to manipulate the arrows in the plot).", "default": null, "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "ignore_missing_samples", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "This will suppress the error raised when the coordinates matrix contains samples that are not present in the metadata. Samples without metadata are included by setting all metadata values to: \"This sample has no metadata\". This flag is only applied if at least one sample is present in both the coordinates matrix and the metadata.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "number_of_features", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of most important features (arrows) to display in the ordination. \u201cImportance\u201d is calculated for each feature based on the vector\u2019s magnitude (euclidean distance from origin).", "default": 5, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "diversity": {"id": "diversity", "name": "diversity", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-diversity", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin supports metrics for calculating and exploring community alpha and beta diversity through statistics and visualizations in the context of sample metadata.", "short_description": "Plugin for exploring community diversity.", "actions": {"beta_phylogenetic": {"id": "beta_phylogenetic", "name": "Beta diversity (phylogenetic)", "description": "Computes a user-specified phylogenetic beta diversity metric for all pairs of samples in a feature table.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table containing the samples over which beta diversity should be computed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "phylogeny", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "input", "description": "Phylogenetic tree containing tip identifiers that correspond to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metric", "repr": "Choices('generalized_unifrac', 'weighted_normalized_unifrac', 'weighted_unifrac', 'unweighted_unifrac')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["generalized_unifrac", "weighted_normalized_unifrac", "weighted_unifrac", "unweighted_unifrac"]}, "fields": []}, "type": "parameter", "description": "The beta diversity metric to be computed.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of workers to use.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "variance_adjusted", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Perform variance adjustment based on Chang et al. BMC Bioinformatics 2011. Weights distances based on the proportion of the relative abundance represented between the samples at a given node under evaluation.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "alpha", "repr": "Range(0, 1, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "This parameter is only used when the choice of metric is generalized_unifrac. The value of alpha controls importance of sample proportions. 1.0 is weighted normalized UniFrac. 0.0 is close to unweighted UniFrac, but only if the sample proportions are dichotomized.", "default": null, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "bypass_tips", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "In a bifurcating tree, the tips make up about 50% of the nodes in a tree. By ignoring them, specificity can be traded for reduced compute time. This has the effect of collapsing the phylogeny, and is analogous (in concept) to moving from 99% to 97% OTUs", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "distance_matrix", "repr": "DistanceMatrix % Properties('phylogenetic')", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": {"type": "predicate", "name": "Properties", "include": ["phylogenetic"], "exclude": []}, "fields": []}, "type": "output", "description": "The resulting distance matrix.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "beta": {"id": "beta", "name": "Beta diversity", "description": "Computes a user-specified beta diversity metric for all pairs of samples in a feature table.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table containing the samples over which beta diversity should be computed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metric", "repr": "Choices('kulsinski', 'cosine', 'dice', 'cityblock', 'matching', 'sokalsneath', 'canberra', 'canberra_adkins', 'hamming', 'jaccard', 'mahalanobis', 'wminkowski', 'correlation', 'seuclidean', 'sokalmichener', 'chebyshev', 'sqeuclidean', 'rogerstanimoto', 'euclidean', 'aitchison', 'yule', 'russellrao', 'braycurtis')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["kulsinski", "cosine", "dice", "cityblock", "matching", "sokalsneath", "canberra", "canberra_adkins", "hamming", "jaccard", "mahalanobis", "wminkowski", "correlation", "seuclidean", "sokalmichener", "chebyshev", "sqeuclidean", "rogerstanimoto", "euclidean", "aitchison", "yule", "russellrao", "braycurtis"]}, "fields": []}, "type": "parameter", "description": "The beta diversity metric to be computed.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "pseudocount", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "A pseudocount to handle zeros for compositional metrics.  This is ignored for other metrics.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of jobs to use for the computation. This works by breaking down the pairwise matrix into n_jobs even slices and computing them in parallel. If -1 all CPUs are used. If 1 is given, no parallel computing code is used at all, which is useful for debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for n_jobs = -2, all CPUs but one are used. (Description from sklearn.metrics.pairwise_distances)", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "output", "description": "The resulting distance matrix.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "alpha_phylogenetic": {"id": "alpha_phylogenetic", "name": "Alpha diversity (phylogenetic)", "description": "Computes a user-specified phylogenetic alpha diversity metric for all samples in a feature table.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table containing the samples for which alpha diversity should be computed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "phylogeny", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "input", "description": "Phylogenetic tree containing tip identifiers that correspond to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metric", "repr": "Choices('faith_pd')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["faith_pd"]}, "fields": []}, "type": "parameter", "description": "The alpha diversity metric to be computed.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "alpha_diversity", "repr": "SampleData[AlphaDiversity] % Properties('phylogenetic')", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": {"type": "predicate", "name": "Properties", "include": ["phylogenetic"], "exclude": []}, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "output", "description": "Vector containing per-sample alpha diversities.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "alpha_phylogenetic_alt": {"id": "alpha_phylogenetic_alt", "name": "Alpha diversity (phylogenetic) - alternative implementation", "description": "Computes a user-specified phylogenetic alpha diversity metric for all samples in a feature table. This implementation is recommended for large datasets, otherwise the results are identical to alpha_phylogenetic. \n\nThis method is an implementation of the Stacked Faith Algorithm (manuscript in preparation).", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table containing the samples for which alpha diversity should be computed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "phylogeny", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "input", "description": "Phylogenetic tree containing tip identifiers that correspond to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metric", "repr": "Choices('faith_pd')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["faith_pd"]}, "fields": []}, "type": "parameter", "description": "The alpha diversity metric to be computed.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "alpha_diversity", "repr": "SampleData[AlphaDiversity] % Properties('phylogenetic')", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": {"type": "predicate", "name": "Properties", "include": ["phylogenetic"], "exclude": []}, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "output", "description": "Vector containing per-sample alpha diversities.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "alpha": {"id": "alpha", "name": "Alpha diversity", "description": "Computes a user-specified alpha diversity metric for all samples in a feature table.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table containing the samples for which alpha diversity should be computed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metric", "repr": "Choices('heip_e', 'strong', 'chao1_ci', 'goods_coverage', 'shannon', 'dominance', 'osd', 'berger_parker_d', 'enspie', 'esty_ci', 'lladser_ci', 'robbins', 'fisher_alpha', 'pielou_e', 'mcintosh_d', 'simpson_e', 'ace', 'gini_index', 'kempton_taylor_q', 'michaelis_menten_fit', 'observed_otus', 'chao1', 'margalef', 'menhinick', 'doubles', 'simpson', 'lladser_pe', 'singles', 'brillouin_d', 'mcintosh_e')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["heip_e", "strong", "chao1_ci", "goods_coverage", "shannon", "dominance", "osd", "berger_parker_d", "enspie", "esty_ci", "lladser_ci", "robbins", "fisher_alpha", "pielou_e", "mcintosh_d", "simpson_e", "ace", "gini_index", "kempton_taylor_q", "michaelis_menten_fit", "observed_otus", "chao1", "margalef", "menhinick", "doubles", "simpson", "lladser_pe", "singles", "brillouin_d", "mcintosh_e"]}, "fields": []}, "type": "parameter", "description": "The alpha diversity metric to be computed.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "alpha_diversity", "repr": "SampleData[AlphaDiversity]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "output", "description": "Vector containing per-sample alpha diversities.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "pcoa": {"id": "pcoa", "name": "Principal Coordinate Analysis", "description": "Apply principal coordinate analysis.", "signature": [{"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "input", "description": "The distance matrix on which PCoA should be computed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "number_of_dimensions", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Dimensions to reduce the distance matrix to. This number determines how many eigenvectors and eigenvalues are returned,and influences the choice of algorithm used to compute them. By default, uses the default eigendecomposition method, SciPy's eigh, which computes all eigenvectors and eigenvalues in an exact manner. For very large matrices, this is expected to be slow. If a value is specified for this parameter, then the fast, heuristic eigendecomposition algorithm fsvd is used, which only computes and returns the number of dimensions specified, but suffers some degree of accuracy loss, the magnitude of which varies across different datasets.", "default": null, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "pcoa", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "output", "description": "The resulting PCoA matrix.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "pcoa_biplot": {"id": "pcoa_biplot", "name": "Principal Coordinate Analysis Biplot", "description": "Project features into a principal coordinates matrix. The features used should be the features used to compute the distance matrix. It is recommended that these variables be normalized in cases of dimensionally heterogeneous physical variables.", "signature": [{"name": "pcoa", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "input", "description": "The PCoA where the features will be projected onto.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "features", "repr": "FeatureTable[RelativeFrequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "RelativeFrequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Variables to project onto the PCoA matrix", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "biplot", "repr": "PCoAResults % Properties('biplot')", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": {"type": "predicate", "name": "Properties", "include": ["biplot"], "exclude": []}, "fields": []}, "type": "output", "description": "The resulting PCoA matrix.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "procrustes_analysis": {"id": "procrustes_analysis", "name": "Procrustes Analysis", "description": "Fit two ordination matrices with Procrustes analysis", "signature": [{"name": "reference", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "input", "description": "The ordination matrix to which data is fitted to.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "other", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "input", "description": "The ordination matrix that's fitted to the reference ordination.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "dimensions", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "default": 5, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "transformed_reference", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "output", "description": "A normalized version of the \"reference\" ordination matrix.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "transformed_other", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "output", "description": "A normalized and fitted version of the \"other\" ordination matrix.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "filter_distance_matrix": {"id": "filter_distance_matrix", "name": "Filter samples from a distance matrix.", "description": "Filter samples from a distance matrix, retaining only the samples matching search criteria specified by `metadata` and `where` parameters (or retaining only the samples not matching that criteria, if `exclude_ids` is True). See the filtering tutorial on https://docs.qiime2.org for additional details.", "signature": [{"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "input", "description": "Distance matrix to filter by sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata used with `where` parameter when selecting samples to retain, or with `exclude_ids` when selecting samples to discard.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "where", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "SQLite WHERE clause specifying sample metadata criteria that must be met to be included in the filtered distance matrix. If not provided, all samples in `metadata` that are also in the input distance matrix will be retained.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "exclude_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If `True`, the samples selected by `metadata` or `where` parameters will be excluded from the filtered distance matrix instead of being retained.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "filtered_distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "output", "description": "Distance matrix filtered to include samples matching search criteria", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "alpha_group_significance": {"id": "alpha_group_significance", "name": "Alpha diversity comparisons", "description": "Visually and statistically compare groups of alpha diversity values.", "signature": [{"name": "alpha_diversity", "repr": "SampleData[AlphaDiversity]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "input", "description": "Vector of alpha diversity values by sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "bioenv": {"id": "bioenv", "name": "bioenv", "description": "Find the subsets of variables in metadata whose Euclidean distances are maximally rank-correlated with distance matrix. All numeric variables in metadata will be considered, and samples which are missing data will be dropped. The output visualization will indicate how many samples were dropped due to missing data, if any were dropped.", "signature": [{"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "input", "description": "Matrix of distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "beta_group_significance": {"id": "beta_group_significance", "name": "Beta diversity group significance", "description": "Determine whether groups of samples are significantly different from one another using a permutation-based statistical test.", "signature": [{"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "input", "description": "Matrix of distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Categorical sample metadata column.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "method", "repr": "Choices('permanova', 'anosim', 'permdisp')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["permanova", "anosim", "permdisp"]}, "fields": []}, "type": "parameter", "description": "The group significance test to be applied.", "default": "permanova", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "pairwise", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Perform pairwise tests between all pairs of groups in addition to the test across all groups. This can be very slow if there are a lot of groups in the metadata column.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "permutations", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of permutations to be run when computing p-values.", "default": 999, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "mantel": {"id": "mantel", "name": "Apply the Mantel test to two distance matrices", "description": "Apply a two-sided Mantel test to identify correlation between two distance matrices.\n\nNote: the directionality of the comparison has no bearing on the results. Thus, comparing distance matrix X to distance matrix Y is equivalent to comparing Y to X.\n\nNote: the order of samples within the two distance matrices does not need to be the same; the distance matrices will be reordered before applying the Mantel test.\n\nSee the scikit-bio docs for more details about the Mantel test:\n\nhttp://scikit-bio.org/docs/latest/generated/generated/skbio.stats.distance.mantel.html", "signature": [{"name": "dm1", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "input", "description": "Matrix of distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "dm2", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "input", "description": "Matrix of distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "method", "repr": "Choices('spearman', 'pearson')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["spearman", "pearson"]}, "fields": []}, "type": "parameter", "description": "The correlation test to be applied in the Mantel test.", "default": "spearman", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "permutations", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of permutations to be run when computing p-values. Supplying a value of zero will disable permutation testing and p-values will not be calculated (this results in *much* quicker execution time if p-values are not desired).", "default": 999, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "intersect_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If supplied, IDs that are not found in both distance matrices will be discarded before applying the Mantel test. Default behavior is to error on any mismatched IDs.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "label1", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Label for `dm1` in the output visualization.", "default": "Distance Matrix 1", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "label2", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Label for `dm2` in the output visualization.", "default": "Distance Matrix 2", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "alpha_correlation": {"id": "alpha_correlation", "name": "Alpha diversity correlation", "description": "Determine whether numeric sample metadata columns are correlated with alpha diversity.", "signature": [{"name": "alpha_diversity", "repr": "SampleData[AlphaDiversity]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "input", "description": "Vector of alpha diversity values by sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "method", "repr": "Choices('spearman', 'pearson')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["spearman", "pearson"]}, "fields": []}, "type": "parameter", "description": "The correlation test to be applied.", "default": "spearman", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "intersect_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If supplied, IDs that are not found in both the alpha diversity vector and metadata will be discarded before calculating the correlation. Default behavior is to error on any mismatched IDs.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "alpha_rarefaction": {"id": "alpha_rarefaction", "name": "Alpha rarefaction curves", "description": "Generate interactive alpha rarefaction curves by computing rarefactions between `min_depth` and `max_depth`. The number of intermediate depths to compute is controlled by the `steps` parameter, with n `iterations` being computed at each rarefaction depth. If sample metadata is provided, samples may be grouped based on distinct values within a metadata column.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table to compute rarefaction curves from.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_depth", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The maximum rarefaction depth. Must be greater than min_depth.", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "phylogeny", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "input", "description": "Optional phylogeny for phylogenetic metrics.", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metrics", "repr": "Choices('menhinick', 'doubles', 'heip_e', 'simpson', 'faith_pd', 'goods_coverage', 'shannon', 'dominance', 'lladser_pe', 'berger_parker_d', 'enspie', 'singles', 'robbins', 'fisher_alpha', 'pielou_e', 'mcintosh_d', 'simpson_e', 'brillouin_d', 'ace', 'observed_otus', 'gini_index', 'michaelis_menten_fit', 'chao1', 'margalef', 'mcintosh_e')", "ast": {"type": "expression", "builtin": true, "name": "Set", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["menhinick", "doubles", "heip_e", "simpson", "faith_pd", "goods_coverage", "shannon", "dominance", "lladser_pe", "berger_parker_d", "enspie", "singles", "robbins", "fisher_alpha", "pielou_e", "mcintosh_d", "simpson_e", "brillouin_d", "ace", "observed_otus", "gini_index", "michaelis_menten_fit", "chao1", "margalef", "mcintosh_e"]}, "fields": []}]}, "type": "parameter", "description": "The metrics to be measured. By default computes observed_otus, shannon, and if phylogeny is provided, faith_pd.", "default": null, "metavar": "TEXT...", "multiple": "set", "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata.", "default": null, "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "min_depth", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The minimum rarefaction depth.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "steps", "repr": "Range(2, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [2, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of rarefaction depths to include between min_depth and max_depth.", "default": 10, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "iterations", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of rarefied feature tables to compute at each step.", "default": 10, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "beta_rarefaction": {"id": "beta_rarefaction", "name": "Beta diversity rarefaction", "description": "Repeatedly rarefy a feature table to compare beta diversity results within a given rarefaction depth.\n\nFor a given beta diversity metric, this visualizer will provide: an Emperor jackknifed PCoA plot, samples clustered by UPGMA or neighbor joining with support calculation, and a heatmap showing the correlation between rarefaction trials of that beta diversity metric.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "Feature table upon which to perform beta diversity rarefaction analyses.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metric", "repr": "Choices('kulsinski', 'cosine', 'dice', 'jaccard', 'mahalanobis', 'cityblock', 'wminkowski', 'matching', 'correlation', 'seuclidean', 'sokalmichener', 'chebyshev', 'sokalsneath', 'sqeuclidean', 'generalized_unifrac', 'rogerstanimoto', 'euclidean', 'canberra', 'aitchison', 'unweighted_unifrac', 'weighted_normalized_unifrac', 'yule', 'russellrao', 'canberra_adkins', 'braycurtis', 'hamming', 'weighted_unifrac')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["kulsinski", "cosine", "dice", "jaccard", "mahalanobis", "cityblock", "wminkowski", "matching", "correlation", "seuclidean", "sokalmichener", "chebyshev", "sokalsneath", "sqeuclidean", "generalized_unifrac", "rogerstanimoto", "euclidean", "canberra", "aitchison", "unweighted_unifrac", "weighted_normalized_unifrac", "yule", "russellrao", "canberra_adkins", "braycurtis", "hamming", "weighted_unifrac"]}, "fields": []}, "type": "parameter", "description": "The beta diversity metric to be computed.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "clustering_method", "repr": "Choices('nj', 'upgma')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["nj", "upgma"]}, "fields": []}, "type": "parameter", "description": "Samples can be clustered with neighbor joining or UPGMA. An arbitrary rarefaction trial will be used for the tree, and the remaining trials are used to calculate the support of the internal nodes of that tree.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata used for the Emperor jackknifed PCoA plot.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "sampling_depth", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The total frequency that each sample should be rarefied to prior to computing the diversity metric.", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "iterations", "repr": "Range(2, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [2, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of times to rarefy the feature table at a given sampling depth.", "default": 10, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "phylogeny", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "input", "description": "Phylogenetic tree containing tip identifiers that correspond to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree. [required for phylogenetic metrics]", "default": null, "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "correlation_method", "repr": "Choices('spearman', 'pearson')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["spearman", "pearson"]}, "fields": []}, "type": "parameter", "description": "The Mantel correlation test to be applied when computing correlation between beta diversity distance matrices.", "default": "spearman", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "color_scheme", "repr": "Choices('BrBG', 'BrBG_r', 'PRGn', 'PRGn_r', 'PiYG', 'PiYG_r', 'PuOr', 'PuOr_r', 'RdBu', 'RdBu_r', 'RdGy', 'RdGy_r', 'RdYlBu', 'RdYlBu_r', 'RdYlGn', 'RdYlGn_r')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["BrBG", "BrBG_r", "PRGn", "PRGn_r", "PiYG", "PiYG_r", "PuOr", "PuOr_r", "RdBu", "RdBu_r", "RdGy", "RdGy_r", "RdYlBu", "RdYlBu_r", "RdYlGn", "RdYlGn_r"]}, "fields": []}, "type": "parameter", "description": "The matplotlib color scheme to generate the heatmap with.", "default": "BrBG", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "adonis": {"id": "adonis", "name": "adonis PERMANOVA test for beta group significance", "description": "Determine whether groups of samples are significantly different from one another using the ADONIS permutation-based statistical test in vegan-R. The function partitions sums of squares of a multivariate data set, and is directly analogous to MANOVA (multivariate analysis of variance). This action differs from beta_group_significance in that it accepts R formulae to perform multi-way ADONIS tests; beta_group_signficance only performs one-way tests. For more details see http://cc.oulu.fi/~jarioksa/softhelp/vegan/html/adonis.html", "signature": [{"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "input", "description": "Matrix of distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata containing formula terms.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "formula", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Model formula containing only independent terms contained in the sample metadata. These can be continuous variables or factors, and they can have interactions as in a typical R formula. E.g., the formula \"treatment+block\" would test whether the input distance matrix partitions based on \"treatment\" and \"block\" sample metadata. The formula \"treatment*block\" would test both of those effects as well as their interaction. Enclose formulae in quotes to avoid unpleasant surprises.", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "permutations", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of permutations to be run when computing p-values.", "default": 999, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_jobs", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of parallel processes to run.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "core_metrics_phylogenetic": {"id": "core_metrics_phylogenetic", "name": "Core diversity metrics (phylogenetic and non-phylogenetic)", "description": "Applies a collection of diversity metrics (both phylogenetic and non-phylogenetic) to a feature table.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table containing the samples over which diversity metrics should be computed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "phylogeny", "repr": "Phylogeny[Rooted]", "ast": {"type": "expression", "builtin": false, "name": "Phylogeny", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Rooted", "predicate": null, "fields": []}]}, "type": "input", "description": "Phylogenetic tree containing tip identifiers that correspond to the feature identifiers in the table. This tree can contain tip ids that are not present in the table, but all feature ids in the table must be present in this tree.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sampling_depth", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The total frequency that each sample should be rarefied to prior to computing diversity metrics.", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata to use in the emperor plots.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "n_jobs", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "[beta/beta-phylogenetic methods only, excluding weighted_unifrac] - The number of jobs to use for the computation. This works by breaking down the pairwise matrix into n_jobs even slices and computing them in parallel. If -1 all CPUs are used. If 1 is given, no parallel computing code is used at all, which is useful for debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for n_jobs = -2, all CPUs but one are used. (Description from sklearn.metrics.pairwise_distances)", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "rarefied_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting rarefied feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "faith_pd_vector", "repr": "SampleData[AlphaDiversity]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "output", "description": "Vector of Faith PD values by sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "observed_otus_vector", "repr": "SampleData[AlphaDiversity]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "output", "description": "Vector of Observed OTUs values by sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "shannon_vector", "repr": "SampleData[AlphaDiversity]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "output", "description": "Vector of Shannon diversity values by sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "evenness_vector", "repr": "SampleData[AlphaDiversity]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "output", "description": "Vector of Pielou's evenness values by sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "unweighted_unifrac_distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "output", "description": "Matrix of unweighted UniFrac distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "weighted_unifrac_distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "output", "description": "Matrix of weighted UniFrac distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "jaccard_distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "output", "description": "Matrix of Jaccard distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "bray_curtis_distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "output", "description": "Matrix of Bray-Curtis distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "unweighted_unifrac_pcoa_results", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "output", "description": "PCoA matrix computed from unweighted UniFrac distances between samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "weighted_unifrac_pcoa_results", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "output", "description": "PCoA matrix computed from weighted UniFrac distances between samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "jaccard_pcoa_results", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "output", "description": "PCoA matrix computed from Jaccard distances between samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "bray_curtis_pcoa_results", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "output", "description": "PCoA matrix computed from Bray-Curtis distances between samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "unweighted_unifrac_emperor", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Emperor plot of the PCoA matrix computed from unweighted UniFrac.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "weighted_unifrac_emperor", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Emperor plot of the PCoA matrix computed from weighted UniFrac.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "jaccard_emperor", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Emperor plot of the PCoA matrix computed from Jaccard.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "bray_curtis_emperor", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Emperor plot of the PCoA matrix computed from Bray-Curtis.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "core_metrics": {"id": "core_metrics", "name": "Core diversity metrics (non-phylogenetic)", "description": "Applies a collection of diversity metrics (non-phylogenetic) to a feature table.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table containing the samples over which diversity metrics should be computed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sampling_depth", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The total frequency that each sample should be rarefied to prior to computing diversity metrics.", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "The sample metadata to use in the emperor plots.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "with_replacement", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Rarefy with replacement by sampling from the multinomial distribution instead of rarefying without replacement.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "n_jobs", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "[beta methods only] - The number of jobs to use for the computation. This works by breaking down the pairwise matrix into n_jobs even slices and computing them in parallel. If -1 all CPUs are used. If 1 is given, no parallel computing code is used at all, which is useful for debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for n_jobs = -2, all CPUs but one are used. (Description from sklearn.metrics.pairwise_distances)", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "rarefied_table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting rarefied feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "observed_otus_vector", "repr": "SampleData[AlphaDiversity]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "output", "description": "Vector of Observed OTUs values by sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "shannon_vector", "repr": "SampleData[AlphaDiversity]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "output", "description": "Vector of Shannon diversity values by sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "evenness_vector", "repr": "SampleData[AlphaDiversity]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlphaDiversity", "predicate": null, "fields": []}]}, "type": "output", "description": "Vector of Pielou's evenness values by sample.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "jaccard_distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "output", "description": "Matrix of Jaccard distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "bray_curtis_distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "output", "description": "Matrix of Bray-Curtis distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "jaccard_pcoa_results", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "output", "description": "PCoA matrix computed from Jaccard distances between samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "bray_curtis_pcoa_results", "repr": "PCoAResults", "ast": {"type": "expression", "builtin": false, "name": "PCoAResults", "predicate": null, "fields": []}, "type": "output", "description": "PCoA matrix computed from Bray-Curtis distances between samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "jaccard_emperor", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Emperor plot of the PCoA matrix computed from Jaccard.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "bray_curtis_emperor", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Emperor plot of the PCoA matrix computed from Bray-Curtis.", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "beta_correlation": {"id": "beta_correlation", "name": "Beta diversity correlation", "description": "Create a distance matrix from a numeric metadata column and apply a two-sided Mantel test to identify correlation between two distance matrices. Actions used internally: `distance-matrix` from q2-metadata and `mantel` from q2-diversity.", "signature": [{"name": "metadata", "repr": "MetadataColumn[Numeric]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Numeric", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Numeric metadata column from which to compute pairwise Euclidean distances", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "input", "description": "Matrix of distances between pairs of samples.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "method", "repr": "Choices('spearman', 'pearson')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["spearman", "pearson"]}, "fields": []}, "type": "parameter", "description": "The correlation test to be applied in the Mantel test.", "default": "spearman", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "permutations", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of permutations to be run when computing p-values. Supplying a value of zero will disable permutation testing and p-values will not be calculated (this results in *much* quicker execution time if p-values are not desired).", "default": 999, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "intersect_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If supplied, IDs that are not found in both distance matrices will be discarded before applying the Mantel test. Default behavior is to error on any mismatched IDs.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "label1", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Label for `distance_matrix` in the output visualization.", "default": "Metadata", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "label2", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Label for `metadata_distance_matrix` in the output visualization.", "default": "Distance Matrix", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata_distance_matrix", "repr": "DistanceMatrix", "ast": {"type": "expression", "builtin": false, "name": "DistanceMatrix", "predicate": null, "fields": []}, "type": "output", "description": "The Distance Matrix produced from the metadata column and used in the mantel test", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "mantel_scatter_visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "description": "Scatter plot rendering of the manteltest results", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "demux": {"id": "demux", "name": "demux", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-demux", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin supports demultiplexing of single-end and paired-end sequence reads and visualization of sequence quality information.", "short_description": "Plugin for demultiplexing & viewing sequence quality.", "actions": {"emp_single": {"id": "emp_single", "name": "Demultiplex sequence data generated with the EMP protocol.", "description": "Demultiplex sequence data (i.e., map barcode reads to sample ids) for data generated with the Earth Microbiome Project (EMP) amplicon sequencing protocol. Details about this protocol can be found at http://www.earthmicrobiome.org/protocols-and-standards/", "signature": [{"name": "seqs", "repr": "RawSequences | EMPSingleEndSequences | EMPPairedEndSequences", "ast": {"type": "union", "members": [{"type": "expression", "builtin": false, "name": "RawSequences", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "EMPSingleEndSequences", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "EMPPairedEndSequences", "predicate": null, "fields": []}]}, "type": "input", "description": "The single-end sequences to be demultiplexed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "barcodes", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "The sample metadata column containing the per-sample barcodes.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "golay_error_correction", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Perform 12nt Golay error correction on the barcode reads.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "rev_comp_barcodes", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If provided, the barcode sequence reads will be reverse complemented prior to demultiplexing.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "rev_comp_mapping_barcodes", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If provided, the barcode sequences in the sample metadata will be reverse complemented prior to demultiplexing.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "per_sample_sequences", "repr": "SampleData[SequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting demultiplexed sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "error_correction_details", "repr": "ErrorCorrectionDetails", "ast": {"type": "expression", "builtin": false, "name": "ErrorCorrectionDetails", "predicate": null, "fields": []}, "type": "output", "description": "Detail about the barcode error corrections.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "emp_paired": {"id": "emp_paired", "name": "Demultiplex paired-end sequence data generated with the EMP protocol.", "description": "Demultiplex paired-end sequence data (i.e., map barcode reads to sample ids) for data generated with the Earth Microbiome Project (EMP) amplicon sequencing protocol. Details about this protocol can be found at http://www.earthmicrobiome.org/protocols-and-standards/", "signature": [{"name": "seqs", "repr": "EMPPairedEndSequences", "ast": {"type": "expression", "builtin": false, "name": "EMPPairedEndSequences", "predicate": null, "fields": []}, "type": "input", "description": "The paired-end sequences to be demultiplexed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "barcodes", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "The sample metadata column containing the per-sample barcodes.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "golay_error_correction", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Perform 12nt Golay error correction on the barcode reads.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "rev_comp_barcodes", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If provided, the barcode sequence reads will be reverse complemented prior to demultiplexing.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "rev_comp_mapping_barcodes", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If provided, the barcode sequences in the sample metadata will be reverse complemented prior to demultiplexing.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "per_sample_sequences", "repr": "SampleData[PairedEndSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting demultiplexed sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "error_correction_details", "repr": "ErrorCorrectionDetails", "ast": {"type": "expression", "builtin": false, "name": "ErrorCorrectionDetails", "predicate": null, "fields": []}, "type": "output", "description": "Detail about the barcode error corrections.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "subsample_single": {"id": "subsample_single", "name": "Subsample single-end sequences without replacement.", "description": "Generate a random subsample of single-end sequences containing approximately the fraction of input sequences specified by the fraction parameter. The number of output samples will always be equal to the number of input samples, even if some of those samples contain no sequences after subsampling.", "signature": [{"name": "sequences", "repr": "SampleData[SequencesWithQuality | PairedEndSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The demultiplexed sequences to be subsampled.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "fraction", "repr": "Range(0, 1, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "The fraction of sequences to retain in subsample.", "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "subsampled_sequences", "repr": "SampleData[SequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}]}, "type": "output", "description": "The subsampled sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "subsample_paired": {"id": "subsample_paired", "name": "Subsample paired-end sequences without replacement.", "description": "Generate a random subsample of paired-end sequences containing approximately the fraction of input sequences specified by the fraction parameter. The number of output samples will always be equal to the number of input samples, even if some of those samples contain no sequences after subsampling.", "signature": [{"name": "sequences", "repr": "SampleData[PairedEndSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}]}, "type": "input", "description": "The demultiplexed sequences to be subsampled.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "fraction", "repr": "Range(0, 1, inclusive_start=False)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [false, false]}, "fields": []}, "type": "parameter", "description": "The fraction of sequences to retain in subsample.", "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "subsampled_sequences", "repr": "SampleData[PairedEndSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}]}, "type": "output", "description": "The subsampled sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "filter_samples": {"id": "filter_samples", "name": "Filter samples out of demultiplexed data.", "description": "Filter samples indicated in given metadata out of demultiplexed data. Specific samples can be further selected with the WHERE clause, and the `exclude_ids` parameter allows for filtering of all samples not specified.", "signature": [{"name": "demux", "repr": "SampleData[SequencesWithQuality\u00b9 | PairedEndSequencesWithQuality\u00b2 | JoinedSequencesWithQuality\u00b3]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "variable", "index": 1, "group": 140664428802120, "outputs": 1, "mapping": [[{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "JoinedSequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "JoinedSequencesWithQuality", "predicate": null, "fields": []}]]}]}, "type": "input", "description": "The demultiplexed data from which samples should be filtered.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Metadata", "predicate": null, "fields": []}, "type": "parameter", "description": "Sample metadata indicating which sample ids to filter. The optional `where` parameter may be used to filter ids based on specified conditions in the metadata. The optional `exclude_ids` parameter may be used to exclude the ids specified in the metadata from the filter.", "metavar": "METADATA...", "multiple": "list", "is_bool_flag": false, "metadata": "file"}, {"name": "where", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}, "type": "parameter", "description": "Optional SQLite WHERE clause specifying sample metadata criteria that must be met to be included in the filtered data. If not provided, all samples in `metadata` that are also in the demultiplexed data will be retained.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "exclude_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Defaults to False. If True, the samples selected by the `metadata` and optional `where` parameter will be excluded from the filtered data.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "filtered_demux", "repr": "SampleData[SequencesWithQuality\u00b9 | PairedEndSequencesWithQuality\u00b2 | JoinedSequencesWithQuality\u00b3]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "variable", "index": 1, "group": 140664428802120, "outputs": 1, "mapping": [[{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}], [{"type": "expression", "builtin": false, "name": "JoinedSequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "JoinedSequencesWithQuality", "predicate": null, "fields": []}]]}]}, "type": "output", "description": "Filtered demultiplexed data.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "summarize": {"id": "summarize", "name": "Summarize counts per sample.", "description": "Summarize counts per sample for all samples, and generate interactive positional quality plots based on `n` randomly selected sequences.", "signature": [{"name": "data", "repr": "SampleData[SequencesWithQuality | PairedEndSequencesWithQuality | JoinedSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "JoinedSequencesWithQuality", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The demultiplexed sequences to be summarized.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of sequences that should be selected at random for quality score plots. The quality plots will present the average positional qualities across all of the sequences selected. If input sequences are paired end, plots will be generated for both forward and reverse reads for the same `n` sequences.", "default": 10000, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "deblur": {"id": "deblur", "name": "deblur", "version": "2019.10.0", "website": "https://github.com/biocore/deblur", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin wraps the Deblur software for performing sequence quality control.", "short_description": "Plugin for sequence quality control with Deblur.", "actions": {"denoise_16S": {"id": "denoise_16S", "name": "Deblur sequences using a 16S positive filter.", "description": "Perform sequence quality control for Illumina data using the Deblur workflow with a 16S reference as a positive filter. Only forward reads are supported at this time. The specific reference used is the 88% OTUs from Greengenes 13_8. This mode of operation should only be used when data were generated from a 16S amplicon protocol on an Illumina platform. The reference is only used to assess whether each sequence is likely to be 16S by a local alignment using SortMeRNA with a permissive e-value; the reference is not used to characterize the sequences.", "signature": [{"name": "demultiplexed_seqs", "repr": "SampleData[SequencesWithQuality | PairedEndSequencesWithQuality | JoinedSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "JoinedSequencesWithQuality", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The demultiplexed sequences to be denoised.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trim_length", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Sequence trim length, specify -1 to disable trimming.", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "left_trim_len", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Sequence trimming from the 5' end. A value of 0 will disable this trim.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_stats", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If true, gather stats per sample.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "mean_error", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The mean per nucleotide error, used for original sequence estimate.", "default": 0.005, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "indel_prob", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "Insertion/deletion (indel) probability (same for N indels).", "default": 0.01, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "indel_max", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Maximum number of insertion/deletions.", "default": 3, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_reads", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Retain only features appearing at least min_reads times across all samples in the resulting feature table.", "default": 10, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_size", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "In each sample, discard all features with an abundance less than min_size.", "default": 2, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "jobs_to_start", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to start (if to run in parallel).", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "hashed_feature_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If true, hash the feature IDs.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting denoised feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "representative_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "stats", "repr": "DeblurStats", "ast": {"type": "expression", "builtin": false, "name": "DeblurStats", "predicate": null, "fields": []}, "type": "output", "description": "Per-sample stats if requested.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "denoise_other": {"id": "denoise_other", "name": "Deblur sequences using a user-specified positive filter.", "description": "Perform sequence quality control for Illumina data using the Deblur workflow, including positive alignment-based filtering. Only forward reads are supported at this time. This mode of execution is particularly useful when operating on non-16S data. For example, to apply Deblur to 18S data, you would want to specify a reference composed of 18S sequences in order to filter out sequences which do not appear to be 18S. The assessment is performed by local alignment using SortMeRNA with a permissive e-value threshold.", "signature": [{"name": "demultiplexed_seqs", "repr": "SampleData[SequencesWithQuality | PairedEndSequencesWithQuality | JoinedSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "JoinedSequencesWithQuality", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The demultiplexed sequences to be denoised.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "reference_seqs", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "Positive filtering database. Keep all sequences aligning to these sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trim_length", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Sequence trim length, specify -1 to disable trimming.", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "left_trim_len", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Sequence trimming from the 5' end. A value of 0 will disable this trim.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "sample_stats", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If true, gather stats per sample.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "mean_error", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The mean per nucleotide error, used for original sequence estimate.", "default": 0.005, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "indel_prob", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "Insertion/deletion (indel) probability (same for N indels).", "default": 0.01, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "indel_max", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Maximum number of insertion/deletions.", "default": 3, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_reads", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Retain only features appearing at least min_reads times across all samples in the resulting feature table.", "default": 10, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_size", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "In each sample, discard all features with an abundance less than min_size.", "default": 2, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "jobs_to_start", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Number of jobs to start (if to run in parallel).", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "hashed_feature_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If true, hash the feature IDs.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting denoised feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "representative_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "stats", "repr": "DeblurStats", "ast": {"type": "expression", "builtin": false, "name": "DeblurStats", "predicate": null, "fields": []}, "type": "output", "description": "Per-sample stats if requested.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "visualize_stats": {"id": "visualize_stats", "name": "Visualize Deblur stats per sample.", "description": "Display Deblur statistics per sample", "signature": [{"name": "deblur_stats", "repr": "DeblurStats", "ast": {"type": "expression", "builtin": false, "name": "DeblurStats", "predicate": null, "fields": []}, "type": "input", "description": "Summary statistics of the Deblur process.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "dada2": {"id": "dada2", "name": "dada2", "version": "2019.10.0", "website": "http://benjjneb.github.io/dada2/", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin wraps DADA2 and supports sequence quality control for single-end and paired-end reads using the DADA2 R library.", "short_description": "Plugin for sequence quality control with DADA2.", "actions": {"denoise_single": {"id": "denoise_single", "name": "Denoise and dereplicate single-end sequences", "description": "This method denoises single-end sequences, dereplicates them, and filters chimeras.", "signature": [{"name": "demultiplexed_seqs", "repr": "SampleData[SequencesWithQuality | PairedEndSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "union", "members": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}, {"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}]}]}, "type": "input", "description": "The single-end demultiplexed sequences to be denoised.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trunc_len", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Position at which sequences should be truncated due to decrease in quality. This truncates the 3' end of the of the input sequences, which will be the bases that were sequenced in the last cycles. Reads that are shorter than this value will be discarded. If 0 is provided, no truncation or length filtering will be performed", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trim_left", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Position at which sequences should be trimmed due to low quality. This trims the 5' end of the of the input sequences, which will be the bases that were sequenced in the first cycles.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_ee", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "Reads with number of expected errors higher than this value will be discarded.", "default": 2.0, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trunc_q", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Reads are truncated at the first instance of a quality score less than or equal to this value. If the resulting read is then shorter than `trunc_len`, it is discarded.", "default": 2, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "chimera_method", "repr": "Choices('none', 'consensus', 'pooled')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["none", "consensus", "pooled"]}, "fields": []}, "type": "parameter", "description": "The method used to remove chimeras. \"none\": No chimera removal is performed. \"pooled\": All reads are pooled prior to chimera detection. \"consensus\": Chimeras are detected in samples individually, and sequences found chimeric in a sufficient fraction of samples are removed.", "default": "consensus", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_fold_parent_over_abundance", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The minimum abundance of potential parents of a sequence being tested as chimeric, expressed as a fold-change versus the abundance of the sequence being tested. Values should be greater than or equal to 1 (i.e. parents should be more abundant than the sequence being tested). This parameter has no effect if chimera_method is \"none\".", "default": 1.0, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_threads", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of threads to use for multithreaded processing. If 0 is provided, all available cores will be used.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_reads_learn", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of reads to use when training the error model. Smaller numbers will result in a shorter run time but a less reliable error model.", "default": 1000000, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "hashed_feature_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If true, the feature ids in the resulting table will be presented as hashes of the sequences defining each feature. The hash will always be the same for the same sequence so this allows feature tables to be merged across runs of this method. You should only merge tables if the exact same parameters are used for each run.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "representative_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature sequences. Each feature in the feature table will be represented by exactly one sequence.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "denoising_stats", "repr": "SampleData[DADA2Stats]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "DADA2Stats", "predicate": null, "fields": []}]}, "type": "output", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "denoise_paired": {"id": "denoise_paired", "name": "Denoise and dereplicate paired-end sequences", "description": "This method denoises paired-end sequences, dereplicates them, and filters chimeras.", "signature": [{"name": "demultiplexed_seqs", "repr": "SampleData[PairedEndSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}]}, "type": "input", "description": "The paired-end demultiplexed sequences to be denoised.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trunc_len_f", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Position at which forward read sequences should be truncated due to decrease in quality. This truncates the 3' end of the of the input sequences, which will be the bases that were sequenced in the last cycles. Reads that are shorter than this value will be discarded. After this parameter is applied there must still be at least a 20 nucleotide overlap between the forward and reverse reads. If 0 is provided, no truncation or length filtering will be performed", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trunc_len_r", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Position at which reverse read sequences should be truncated due to decrease in quality. This truncates the 3' end of the of the input sequences, which will be the bases that were sequenced in the last cycles. Reads that are shorter than this value will be discarded. After this parameter is applied there must still be at least a 20 nucleotide overlap between the forward and reverse reads. If 0 is provided, no truncation or length filtering will be performed", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trim_left_f", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Position at which forward read sequences should be trimmed due to low quality. This trims the 5' end of the input sequences, which will be the bases that were sequenced in the first cycles.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trim_left_r", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Position at which reverse read sequences should be trimmed due to low quality. This trims the 5' end of the input sequences, which will be the bases that were sequenced in the first cycles.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_ee_f", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "Forward reads with number of expected errors higher than this value will be discarded.", "default": 2.0, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_ee_r", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "Reverse reads with number of expected errors higher than this value will be discarded.", "default": 2.0, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trunc_q", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Reads are truncated at the first instance of a quality score less than or equal to this value. If the resulting read is then shorter than `trunc_len_f` or `trunc_len_r` (depending on the direction of the read) it is discarded.", "default": 2, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "chimera_method", "repr": "Choices('none', 'consensus', 'pooled')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["none", "consensus", "pooled"]}, "fields": []}, "type": "parameter", "description": "The method used to remove chimeras. \"none\": No chimera removal is performed. \"pooled\": All reads are pooled prior to chimera detection. \"consensus\": Chimeras are detected in samples individually, and sequences found chimeric in a sufficient fraction of samples are removed.", "default": "consensus", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_fold_parent_over_abundance", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The minimum abundance of potential parents of a sequence being tested as chimeric, expressed as a fold-change versus the abundance of the sequence being tested. Values should be greater than or equal to 1 (i.e. parents should be more abundant than the sequence being tested). This parameter has no effect if chimera_method is \"none\".", "default": 1.0, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_threads", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of threads to use for multithreaded processing. If 0 is provided, all available cores will be used.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_reads_learn", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of reads to use when training the error model. Smaller numbers will result in a shorter run time but a less reliable error model.", "default": 1000000, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "hashed_feature_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If true, the feature ids in the resulting table will be presented as hashes of the sequences defining each feature. The hash will always be the same for the same sequence so this allows feature tables to be merged across runs of this method. You should only merge tables if the exact same parameters are used for each run.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "representative_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature sequences. Each feature in the feature table will be represented by exactly one sequence, and these sequences will be the joined paired-end sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "denoising_stats", "repr": "SampleData[DADA2Stats]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "DADA2Stats", "predicate": null, "fields": []}]}, "type": "output", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "denoise_pyro": {"id": "denoise_pyro", "name": "Denoise and dereplicate single-end pyrosequences", "description": "This method denoises single-end pyrosequencing sequences, dereplicates them, and filters chimeras.", "signature": [{"name": "demultiplexed_seqs", "repr": "SampleData[SequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}]}, "type": "input", "description": "The single-end demultiplexed pyrosequencing sequences (e.g. 454, IonTorrent) to be denoised.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trunc_len", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Position at which sequences should be truncated due to decrease in quality. This truncates the 3' end of the of the input sequences, which will be the bases that were sequenced in the last cycles. Reads that are shorter than this value will be discarded. If 0 is provided, no truncation or length filtering will be performed", "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trim_left", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Position at which sequences should be trimmed due to low quality. This trims the 5' end of the of the input sequences, which will be the bases that were sequenced in the first cycles.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_ee", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "Reads with number of expected errors higher than this value will be discarded.", "default": 2.0, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "trunc_q", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Reads are truncated at the first instance of a quality score less than or equal to this value. If the resulting read is then shorter than `trunc_len`, it is discarded.", "default": 2, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_len", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "Remove reads prior to trimming or truncation which are longer than this value. If 0 is provided no reads will be removed based on length.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "chimera_method", "repr": "Choices('none', 'consensus', 'pooled')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["none", "consensus", "pooled"]}, "fields": []}, "type": "parameter", "description": "The method used to remove chimeras. \"none\": No chimera removal is performed. \"pooled\": All reads are pooled prior to chimera detection. \"consensus\": Chimeras are detected in samples individually, and sequences found chimeric in a sufficient fraction of samples are removed.", "default": "consensus", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_fold_parent_over_abundance", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": null, "fields": []}, "type": "parameter", "description": "The minimum abundance of potential parents of a sequence being tested as chimeric, expressed as a fold-change versus the abundance of the sequence being tested. Values should be greater than or equal to 1 (i.e. parents should be more abundant than the sequence being tested). This parameter has no effect if chimera_method is \"none\".", "default": 1.0, "metavar": "NUMBER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_threads", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of threads to use for multithreaded processing. If 0 is provided, all available cores will be used.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_reads_learn", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The number of reads to use when training the error model. Smaller numbers will result in a shorter run time but a less reliable error model.", "default": 250000, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "hashed_feature_ids", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "If true, the feature ids in the resulting table will be presented as hashes of the sequences defining each feature. The hash will always be the same for the same sequence so this allows feature tables to be merged across runs of this method. You should only merge tables if the exact same parameters are used for each run.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "representative_sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature sequences. Each feature in the feature table will be represented by exactly one sequence.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "denoising_stats", "repr": "SampleData[DADA2Stats]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "DADA2Stats", "predicate": null, "fields": []}]}, "type": "output", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "cutadapt": {"id": "cutadapt", "name": "cutadapt", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-cutadapt", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin uses cutadapt to work with adapters (e.g. barcodes, primers) in sequence data.", "short_description": "Plugin for removing adapter sequences, primers, and other unwanted sequence from sequence data.", "actions": {"trim_single": {"id": "trim_single", "name": "Find and remove adapters in demultiplexed single-end sequences.", "description": "Search demultiplexed single-end sequences for adapters and remove them. The parameter descriptions in this method are adapted from the official cutadapt docs - please see those docs at https://cutadapt.readthedocs.io for complete details.", "signature": [{"name": "demultiplexed_sequences", "repr": "SampleData[SequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}]}, "type": "input", "description": "The single-end sequences to be trimmed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "cores", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of CPU cores to use.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "adapter", "repr": "List[Str]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Sequence of an adapter ligated to the 3' end. The adapter and any subsequent bases are trimmed. If a `$` is appended, the adapter is only found if it is at the end of the read. If your sequence of interest is \"framed\" by a 5' and a 3' adapter, use this parameter to define a \"linked\" primer - see https://cutadapt.readthedocs.io for complete details.", "default": null, "metavar": "TEXT...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "front", "repr": "List[Str]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Sequence of an adapter ligated to the 5' end. The adapter and any preceding bases are trimmed. Partial matches at the 5' end are allowed. If a `^` character is prepended, the adapter is only found if it is at the beginning of the read.", "default": null, "metavar": "TEXT...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "anywhere", "repr": "List[Str]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Sequence of an adapter that may be ligated to the 5' or 3' end. Both types of matches as described under `adapter` and `front` are allowed. If the first base of the read is part of the match, the behavior is as with `front`, otherwise as with `adapter`. This option is mostly for rescuing failed library preparations - do not use if you know which end your adapter was ligated to.", "default": null, "metavar": "TEXT...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "error_rate", "repr": "Range(0, 1, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "Maximum allowed error rate.", "default": 0.1, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "indels", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Allow insertions or deletions of bases when matching adapters.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "times", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Remove multiple occurrences of an adapter if it is repeated, up to `times` times.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "overlap", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Require at least `overlap` bases of overlap between read and adapter for an adapter to be found.", "default": 3, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "match_read_wildcards", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Interpret IUPAC wildcards (e.g., N) in reads.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "match_adapter_wildcards", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Interpret IUPAC wildcards (e.g., N) in adapters.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "minimum_length", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Discard reads shorter than specified value. Note, the cutadapt default of 0 has been overridden, because that value produces empty sequence records.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "discard_untrimmed", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Discard reads in which no adapter was found.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "trimmed_sequences", "repr": "SampleData[SequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting trimmed sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "trim_paired": {"id": "trim_paired", "name": "Find and remove adapters in demultiplexed paired-end sequences.", "description": "Search demultiplexed paired-end sequences for adapters and remove them. The parameter descriptions in this method are adapted from the official cutadapt docs - please see those docs at https://cutadapt.readthedocs.io for complete details.", "signature": [{"name": "demultiplexed_sequences", "repr": "SampleData[PairedEndSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}]}, "type": "input", "description": "The paired-end sequences to be trimmed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "cores", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Number of CPU cores to use.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "adapter_f", "repr": "List[Str]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Sequence of an adapter ligated to the 3' end. The adapter and any subsequent bases are trimmed. If a `$` is appended, the adapter is only found if it is at the end of the read. Search in forward read. If your sequence of interest is \"framed\" by a 5' and a 3' adapter, use this parameter to define a \"linked\" primer - see https://cutadapt.readthedocs.io for complete details.", "default": null, "metavar": "TEXT...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "front_f", "repr": "List[Str]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Sequence of an adapter ligated to the 5' end. The adapter and any preceding bases are trimmed. Partial matches at the 5' end are allowed. If a `^` character is prepended, the adapter is only found if it is at the beginning of the read. Search in forward read.", "default": null, "metavar": "TEXT...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "anywhere_f", "repr": "List[Str]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Sequence of an adapter that may be ligated to the 5' or 3' end. Both types of matches as described under `adapter` and `front` are allowed. If the first base of the read is part of the match, the behavior is as with `front`, otherwise as with `adapter`. This option is mostly for rescuing failed library preparations - do not use if you know which end your adapter was ligated to. Search in forward read.", "default": null, "metavar": "TEXT...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "adapter_r", "repr": "List[Str]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Sequence of an adapter ligated to the 3' end. The adapter and any subsequent bases are trimmed. If a `$` is appended, the adapter is only found if it is at the end of the read. Search in reverse read. If your sequence of interest is \"framed\" by a 5' and a 3' adapter, use this parameter to define a \"linked\" primer - see https://cutadapt.readthedocs.io for complete details.", "default": null, "metavar": "TEXT...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "front_r", "repr": "List[Str]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Sequence of an adapter ligated to the 5' end. The adapter and any preceding bases are trimmed. Partial matches at the 5' end are allowed. If a `^` character is prepended, the adapter is only found if it is at the beginning of the read. Search in reverse read.", "default": null, "metavar": "TEXT...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "anywhere_r", "repr": "List[Str]", "ast": {"type": "expression", "builtin": true, "name": "List", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Str", "predicate": null, "fields": []}]}, "type": "parameter", "description": "Sequence of an adapter that may be ligated to the 5' or 3' end. Both types of matches as described under `adapter` and `front` are allowed. If the first base of the read is part of the match, the behavior is as with `front`, otherwise as with `adapter`. This option is mostly for rescuing failed library preparations - do not use if you know which end your adapter was ligated to. Search in reverse read.", "default": null, "metavar": "TEXT...", "multiple": "list", "is_bool_flag": false, "metadata": null}, {"name": "error_rate", "repr": "Range(0, 1, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "Maximum allowed error rate.", "default": 0.1, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "indels", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Allow insertions or deletions of bases when matching adapters.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "times", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Remove multiple occurrences of an adapter if it is repeated, up to `times` times.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "overlap", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Require at least `overlap` bases of overlap between read and adapter for an adapter to be found.", "default": 3, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "match_read_wildcards", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Interpret IUPAC wildcards (e.g., N) in reads.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "match_adapter_wildcards", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Interpret IUPAC wildcards (e.g., N) in adapters.", "default": true, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "minimum_length", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Discard reads shorter than specified value. Note, the cutadapt default of 0 has been overridden, because that value produces empty sequence records.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "discard_untrimmed", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "Discard reads in which no adapter was found.", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "trimmed_sequences", "repr": "SampleData[PairedEndSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting trimmed sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "demux_single": {"id": "demux_single", "name": "Demultiplex single-end sequence data with barcodes in-sequence.", "description": "Demultiplex sequence data (i.e., map barcode reads to sample ids). Barcodes are expected to be located within the sequence data (versus the header, or a separate barcode file).", "signature": [{"name": "seqs", "repr": "MultiplexedSingleEndBarcodeInSequence", "ast": {"type": "expression", "builtin": false, "name": "MultiplexedSingleEndBarcodeInSequence", "predicate": null, "fields": []}, "type": "input", "description": "The single-end sequences to be demultiplexed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "barcodes", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "The sample metadata column listing the per-sample barcodes.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "error_rate", "repr": "Range(0, 1, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The level of error tolerance, specified as the maximum allowable error rate. The default value specified by cutadapt is 0.1 (=10%), which is greater than `demux emp-*`, which is 0.0 (=0%).", "default": 0.1, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "batch_size", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of samples cutadapt demultiplexes concurrently. Demultiplexing in smaller batches will yield the same result with marginal speed loss, and may solve \"too many files\" errors related to sample quantity. Set to \"0\" to process all samples at once.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "minimum_length", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Discard reads shorter than specified value. Note, the cutadapt default of 0 has been overridden, because that value produces empty sequence records.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "per_sample_sequences", "repr": "SampleData[SequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "SequencesWithQuality", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting demultiplexed sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "untrimmed_sequences", "repr": "MultiplexedSingleEndBarcodeInSequence", "ast": {"type": "expression", "builtin": false, "name": "MultiplexedSingleEndBarcodeInSequence", "predicate": null, "fields": []}, "type": "output", "description": "The sequences that were unmatched to barcodes.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "demux_paired": {"id": "demux_paired", "name": "Demultiplex paired-end sequence data with barcodes in-sequence.", "description": "Demultiplex sequence data (i.e., map barcode reads to sample ids). Barcodes are expected to be located within the sequence data (versus the header, or a separate barcode file).", "signature": [{"name": "seqs", "repr": "MultiplexedPairedEndBarcodeInSequence", "ast": {"type": "expression", "builtin": false, "name": "MultiplexedPairedEndBarcodeInSequence", "predicate": null, "fields": []}, "type": "input", "description": "The paired-end sequences to be demultiplexed.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "forward_barcodes", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "The sample metadata column listing the per-sample barcodes for the forward reads.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "reverse_barcodes", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "The sample metadata column listing the per-sample barcodes for the reverse reads.", "default": null, "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "error_rate", "repr": "Range(0, 1, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The level of error tolerance, specified as the maximum allowable error rate.", "default": 0.1, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "batch_size", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of samples cutadapt demultiplexes concurrently. Demultiplexing in smaller batches will yield the same result with marginal speed loss, and may solve \"too many files\" errors related to sample quantity. Set to \"0\" to process all samples at once.", "default": 0, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "minimum_length", "repr": "Range(1, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [1, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "Discard reads shorter than specified value. Note, the cutadapt default of 0 has been overridden, because that value produces empty sequence records.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "per_sample_sequences", "repr": "SampleData[PairedEndSequencesWithQuality]", "ast": {"type": "expression", "builtin": false, "name": "SampleData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "PairedEndSequencesWithQuality", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting demultiplexed sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "untrimmed_sequences", "repr": "MultiplexedPairedEndBarcodeInSequence", "ast": {"type": "expression", "builtin": false, "name": "MultiplexedPairedEndBarcodeInSequence", "predicate": null, "fields": []}, "type": "output", "description": "The sequences that were unmatched to barcodes.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "composition": {"id": "composition", "name": "composition", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-composition", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin supports methods for compositional data analysis.", "short_description": "Plugin for compositional data analysis.", "actions": {"add_pseudocount": {"id": "add_pseudocount", "name": "Add pseudocount to table", "description": "Increment all counts in table by pseudocount.", "signature": [{"name": "table", "repr": "FeatureTable[Frequency]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Frequency", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table to which pseudocounts should be added.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "pseudocount", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": null, "fields": []}, "type": "parameter", "description": "The value to add to all counts in the feature table.", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "composition_table", "repr": "FeatureTable[Composition]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Composition", "predicate": null, "fields": []}]}, "type": "output", "description": "The resulting feature table.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "ancom": {"id": "ancom", "name": "Apply ANCOM to identify features that differ in abundance.", "description": "Apply Analysis of Composition of Microbiomes (ANCOM) to identify features that are differentially abundant across groups.", "signature": [{"name": "table", "repr": "FeatureTable[Composition]", "ast": {"type": "expression", "builtin": false, "name": "FeatureTable", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Composition", "predicate": null, "fields": []}]}, "type": "input", "description": "The feature table to be used for ANCOM computation.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "metadata", "repr": "MetadataColumn[Categorical]", "ast": {"type": "expression", "builtin": true, "name": "MetadataColumn", "predicate": null, "fields": [{"type": "expression", "builtin": true, "name": "Categorical", "predicate": null, "fields": []}]}, "type": "parameter", "description": "The categorical sample metadata column to test for differential abundance across.", "metavar": "METADATA", "multiple": null, "is_bool_flag": false, "metadata": "column"}, {"name": "transform_function", "repr": "Choices('sqrt', 'log', 'clr')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["sqrt", "log", "clr"]}, "fields": []}, "type": "parameter", "description": "The method applied to transform feature values before generating volcano plots.", "default": "clr", "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "difference_function", "repr": "Choices('mean_difference', 'f_statistic')", "ast": {"type": "expression", "builtin": true, "name": "Str", "predicate": {"type": "predicate", "name": "Choices", "choices": ["mean_difference", "f_statistic"]}, "fields": []}, "type": "parameter", "description": "The method applied to visualize fold difference in feature abundances across groups for volcano plots.", "default": null, "metavar": "TEXT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "visualization", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Visualization", "predicate": null, "fields": []}, "type": "output", "metavar": "VISUALIZATION", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}, "alignment": {"id": "alignment", "name": "alignment", "version": "2019.10.0", "website": "https://github.com/qiime2/q2-alignment", "user_support_text": "Please post to the QIIME 2 forum for help with this plugin: https://forum.qiime2.org", "description": "This QIIME 2 plugin provides support for generating and manipulating sequence alignments.", "short_description": "Plugin for generating and manipulating alignments.", "actions": {"mafft": {"id": "mafft", "name": "De novo multiple sequence alignment with MAFFT", "description": "Perform de novo multiple sequence alignment using MAFFT.", "signature": [{"name": "sequences", "repr": "FeatureData[Sequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "Sequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The sequences to be aligned.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "n_threads", "repr": "Range(0, None)", "ast": {"type": "expression", "builtin": true, "name": "Int", "predicate": {"type": "predicate", "name": "Range", "range": [0, null], "inclusive": [true, false]}, "fields": []}, "type": "parameter", "description": "The number of threads. (Use 0 to automatically use all available cores)", "default": 1, "metavar": "INTEGER", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "parttree", "repr": null, "ast": {"type": "expression", "builtin": true, "name": "Bool", "predicate": null, "fields": []}, "type": "parameter", "description": "This flag is required if the number of sequences being aligned are larger than 1000000. Disabled by default", "default": false, "metavar": "", "multiple": null, "is_bool_flag": true, "metadata": null}, {"name": "alignment", "repr": "FeatureData[AlignedSequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlignedSequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The aligned sequences.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}, "mask": {"id": "mask", "name": "Positional conservation and gap filtering.", "description": "Mask (i.e., filter) unconserved and highly gapped columns from an alignment. Default min_conservation was chosen to reproduce the mask presented in Lane (1991).", "signature": [{"name": "alignment", "repr": "FeatureData[AlignedSequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlignedSequence", "predicate": null, "fields": []}]}, "type": "input", "description": "The alignment to be masked.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "max_gap_frequency", "repr": "Range(0, 1, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The maximum relative frequency of gap characters in a column for the column to be retained. This relative frequency must be a number between 0.0 and 1.0 (inclusive), where 0.0 retains only those columns without gap characters, and 1.0 retains all columns regardless of gap character frequency.", "default": 1.0, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "min_conservation", "repr": "Range(0, 1, inclusive_end=True)", "ast": {"type": "expression", "builtin": true, "name": "Float", "predicate": {"type": "predicate", "name": "Range", "range": [0, 1], "inclusive": [true, true]}, "fields": []}, "type": "parameter", "description": "The minimum relative frequency of at least one non-gap character in a column for that column to be retained. This relative frequency must be a number between 0.0 and 1.0 (inclusive). For example, if a value of 0.4 is provided, a column will only be retained if it contains at least one character that is present in at least 40% of the sequences.", "default": 0.4, "metavar": "PROPORTION", "multiple": null, "is_bool_flag": false, "metadata": null}, {"name": "masked_alignment", "repr": "FeatureData[AlignedSequence]", "ast": {"type": "expression", "builtin": false, "name": "FeatureData", "predicate": null, "fields": [{"type": "expression", "builtin": false, "name": "AlignedSequence", "predicate": null, "fields": []}]}, "type": "output", "description": "The masked alignment.", "metavar": "ARTIFACT", "multiple": null, "is_bool_flag": false, "metadata": null}], "deprecated": false}}}}}